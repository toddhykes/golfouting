<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ryder Cup Style Golf Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #2ecc71;
            border-bottom-color: #2ecc71;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #2ecc71;
        }

        .btn {
            background: #2ecc71;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #27ae60;
        }

        .btn-secondary {
            background: #3498db;
        }

        .btn-secondary:hover {
            background: #2980b9;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .team-setup {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .team-card {
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 25px;
            background: #f8f9fa;
        }

        .team-card.team-0 {
            border-color: #3498db;
        }

        .team-card.team-1 {
            border-color: #e74c3c;
        }

        .team-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .team-header h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .captain-badge {
            display: inline-block;
            background: #f39c12;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .player-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent;
        }

        .team-0 .player-item {
            border-color: #3498db;
        }

        .team-1 .player-item {
            border-color: #e74c3c;
        }

        .round-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .round-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .round-header h3 {
            color: #2c3e50;
            font-size: 1.5em;
        }

        .matches-grid {
            display: grid;
            gap: 15px;
        }

        .match-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
        }

        .match-header {
            font-weight: 600;
            color: #7f8c8d;
            margin-bottom: 15px;
            text-align: center;
        }

        .match-teams {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 15px;
            align-items: center;
        }

        .match-team {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .match-team.team-0 {
            background: #ebf5fb;
            border: 2px solid #3498db;
        }

        .match-team.team-1 {
            background: #fadbd8;
            border: 2px solid #e74c3c;
        }

        .match-team.winner {
            box-shadow: 0 0 0 3px #f39c12;
        }

        .match-players {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .match-score-input {
            width: 100%;
            text-align: center;
            padding: 8px;
        }

        .vs-divider {
            font-size: 1.5em;
            font-weight: 600;
            color: #95a5a6;
        }

        .score-summary {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin-bottom: 30px;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
        }

        .team-score {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
        }

        .team-score.team-0 {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .team-score.team-1 {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .team-score.leading {
            box-shadow: 0 4px 20px rgba(243, 156, 18, 0.6);
        }

        .team-score h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .team-score .score {
            font-size: 3em;
            font-weight: 700;
        }

        .score-divider {
            font-size: 2em;
            font-weight: 700;
            color: #7f8c8d;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 968px) {
            .team-setup, .grid-2 {
                grid-template-columns: 1fr;
            }
        }

        .result-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .result-badge.win {
            background: #2ecc71;
            color: white;
        }

        .result-badge.loss {
            background: #e74c3c;
            color: white;
        }

        .result-badge.tie {
            background: #95a5a6;
            color: white;
        }

        /* Live Scoring Styles */
        .live-header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .player-selector {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .hole-card {
            background: white;
            border: 3px solid #3498db;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .hole-number {
            font-size: 2.5em;
            font-weight: 700;
            color: #3498db;
            text-align: center;
            margin-bottom: 20px;
        }

        .score-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .score-btn {
            padding: 20px;
            font-size: 1.5em;
            font-weight: 700;
            background: #ecf0f1;
            border: 3px solid #bdc3c7;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: #2c3e50;
        }

        .score-btn:hover {
            transform: scale(1.05);
            border-color: #3498db;
        }

        .score-btn.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        

        .score-btn.eagle {
            background: #f39c12;
            color: white;
            border-color: #e67e22;
        }

        .score-btn.birdie {
            background: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        .score-btn.bogey {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }

        .score-btn.double {
            background: #c0392b;
            color: white;
            border-color: #a93226;
        }

        .scorecard-summary {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .scorecard-holes {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .scorecard-hole {
            text-align: center;
            padding: 10px 5px;
            background: white;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .scorecard-hole.played {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .match-status {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .match-status.losing {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .match-status.tied {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }
    </style>
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÜ Ryder Cup Style Golf Event Tracker</h1>
            <p>Multi-round match play score tracker</p>
            <p>Option for 'blowout bonus' if you want to punish unfair matchups</p>
            <div id="supabaseStatus" style="margin-top: 10px; font-size: 0.9em; opacity: 0.9;"></div>
            <div id="anthropicKeyStatus" style="margin-top: 6px; font-size: 0.9em; opacity: 0.9;"></div>
        </div>

        <div class="content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('setup', event)">Event Setup</button>
                <button class="tab" onclick="switchTab('teams', event)">Team Rosters</button>
                <button class="tab" onclick="switchTab('matchups', event)">Matchups</button>
                <button class="tab" onclick="switchTab('scoring', event)">Scoring</button>
                <button class="tab" onclick="switchTab('livescoreboard', event)">Live Scoreboard</button>
                <button class="tab" onclick="switchTab('live', event)">Live Scoring</button>
                <button class="tab" onclick="switchTab('standings', event)">Standings</button>
            </div>

            <!-- Setup Tab -->
            <div id="setup" class="tab-content active">
                <h2 style="margin-bottom: 20px;">Event Configuration</h2>
                
                <!-- Load Previous Event Section -->
                <div style="background: #f0f9ff; border: 2px solid #3498db; padding: 20px; border-radius: 8px; margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #2c3e50;">üìã Load Previous Event</h3>
                        <div id="eventListStatus" style="font-size: 0.9em; color: #7f8c8d;"></div>
                    </div>
                    
                    <div id="savedEventsList" style="margin-bottom: 15px;">
                        <!-- Saved events will appear here -->
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr auto auto; gap: 10px;">
                        <input type="text" id="eventSearch" placeholder="Search events by name..." 
                               style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 4px;"
                               oninput="filterSavedEvents()">
                        <button class="btn btn-secondary" onclick="refreshEventsList()">
                            üîÑ Refresh
                        </button>
                        <button class="btn btn-danger" onclick="clearLocalStorage()" 
                                style="background: #e74c3c;"
                                title="Clear old local events (keeps Supabase events)">
                            üóëÔ∏è Clear Local
                        </button>
                    </div>
                </div>

                <!-- Anthropic API Key Section -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px solid #95a5a6; margin-bottom: 20px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <h3 style="margin:0; color:#2c3e50;">ü§ñ Anthropic API Key</h3>
                        <span style="font-size:0.8em; color:#7f8c8d;">Required for course search</span>
                    </div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <input type="password" id="anthropicApiKey" placeholder="sk-ant-api03-..."
                            style="flex:1; padding:10px; border:2px solid #e0e0e0; border-radius:4px; font-family:monospace; font-size:0.9em;"
                            oninput="saveAnthropicKey()">
                        <button onclick="toggleApiKeyVisibility()" class="btn btn-secondary" style="padding:10px 14px;" title="Show/hide key">üëÅ</button>
                    </div>
                    <div style="margin-top:6px; font-size:0.8em; color:#7f8c8d;">
                        Your key is stored locally in this browser only. Get yours at <a href="https://console.anthropic.com" target="_blank" style="color:#3498db;">console.anthropic.com</a>
                    </div>
                </div>

                <!-- Create New Event Section -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border: 2px solid #95a5a6;">
                    <h3 style="margin-bottom: 15px; color: #2c3e50;">üÜï Create New Event</h3>
                
                <div class="form-group">
                    <label>Event Name</label>
                    <input type="text" id="eventName" placeholder="e.g., Annual Ryder Cup Challenge" value="Annual Ryder Cup Challenge">
                </div>

                <div class="form-group">
                    <label>Number of Rounds</label>
                    <input type="number" id="numRounds" min="1" max="5" value="1">
                </div>

                
                <div class="form-group">
                    <label>Scoring Type</label>
                    
                    <select id="scoringType">
                        <option value="match">Match Play</option>
                        <option value="stroke" disabled>Stroke Play</option>    
                    </select>
                </div>

                <div class="form-group">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="blowoutBonus" style="width: auto; margin-right: 10px;">
                        <span>Enable Blowout Bonus (+0.05 points per stroke margin if won before hole 17 - Match Play only)</span>
                    </label>
                </div>

                <h3 style="margin: 30px 0 15px 0;">Round Formats</h3>
                <div id="roundFormats"></div>

                <button class="btn" onclick="saveEventSetup()" style="margin-top: 20px;">Save & Continue to Team Rosters</button>
                </div>
            </div>

            <!-- Teams Tab -->
            <div id="teams" class="tab-content">
                <h2 style="margin-bottom: 20px;">Team Rosters</h2>
                
                <div class="team-setup">
                    <div class="team-card team-0">
                        <div class="team-header">
                            <div class="form-group">
                                <label>Team Name</label>
                                <input type="text" id="team0Name" placeholder="e.g., Team USA" value="Team USA">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Add Player</label>
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <input type="text" id="team0NewPlayer" placeholder="Player name" style="flex: 2;" onkeypress="if(event.key==='Enter' && !event.shiftKey) addPlayer(0)">
                                <input type="tel" id="team0NewPhone" placeholder="Phone (optional)" style="flex: 1;" onkeypress="if(event.key==='Enter' && !event.shiftKey) addPlayer(0)">
                                <button class="btn" onclick="addPlayer(0)" style="padding: 12px 20px; white-space: nowrap;">Add</button>
                            </div>
                            <small style="color: #7f8c8d;">Phone format: (555) 123-4567 or 555-123-4567</small>
                        </div>

                        <div id="team0Roster" style="margin-top: 20px;">
                            <!-- Players will be added here -->
                        </div>
                    </div>

                    <div class="team-card team-1">
                        <div class="team-header">
                            <div class="form-group">
                                <label>Team Name</label>
                                <input type="text" id="team1Name" placeholder="e.g., Team Europe" value="Team Europe">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Add Player</label>
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <input type="text" id="team1NewPlayer" placeholder="Player name" style="flex: 2;" onkeypress="if(event.key==='Enter' && !event.shiftKey) addPlayer(1)">
                                <input type="tel" id="team1NewPhone" placeholder="Phone (optional)" style="flex: 1;" onkeypress="if(event.key==='Enter' && !event.shiftKey) addPlayer(1)">
                                <button class="btn" onclick="addPlayer(1)" style="padding: 12px 20px; white-space: nowrap;">Add</button>
                            </div>
                            <small style="color: #7f8c8d;">Phone format: (555) 123-4567 or 555-123-4567</small>
                        </div>

                        <div id="team1Roster" style="margin-top: 20px;">
                            <!-- Players will be added here -->
                        </div>
                    </div>
                </div>

                <button class="btn" onclick="createGolfEvent()" style="margin-top: 30px;">Create Event & Setup Matchups</button>
                
                <div style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; text-align: center;">
                    <p style="margin-bottom: 10px; color: #7f8c8d;">After creating the event, you'll configure matchups for each round</p>
                </div>
            </div>

            <!-- Scoring Tab -->
            <div id="scoring" class="tab-content">
                <div id="scoringContent" class="empty-state">
                    <div class="empty-state-icon">üèåÔ∏è</div>
                    <h3>No Event Created</h3>
                    <p>Complete setup to start scoring matches</p>
                </div>
            </div>

            <!-- Matchups Tab -->
            <div id="matchups" class="tab-content">
                <div id="matchupsContent" class="empty-state">
                    <div class="empty-state-icon">üë•</div>
                    <h3>No Event Created</h3>
                    <p>Create an event to set up matchups</p>
                </div>
            </div>

            <!-- Live Scoreboard Tab -->
            <div id="livescoreboard" class="tab-content">
                <div id="liveScoreboardContent" class="empty-state">
                    <div class="empty-state-icon">üìä</div>
                    <h3>No Event Created</h3>
                    <p>Create an event to see live scores</p>
                </div>
            </div>

            <!-- Live Scoring Tab -->
            <div id="live" class="tab-content">
                <div id="liveContent" class="empty-state">
                    <div class="empty-state-icon">üì±</div>
                    <h3>No Event Created</h3>
                    <p>Create an event to enable live scoring</p>
                </div>
            </div>

            <!-- Standings Tab -->
            <div id="standings" class="tab-content">
                <div id="standingsContent" class="empty-state">
                    <div class="empty-state-icon">üèÜ</div>
                    <h3>No Scores Yet</h3>
                    <p>Start entering match results to see standings</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // SUPABASE CONFIGURATION  
        // ====================================================================
        // Replace these with your actual Supabase project credentials
        // Get them from: Supabase Dashboard ‚Üí Settings ‚Üí API
        
         
        const SUPABASE_URL = 'https://jctsungrazwlhlxxpgpx.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpjdHN1bmdyYXp3bGhseHhwZ3B4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA0NjY5MzMsImV4cCI6MjA4NjA0MjkzM30.u-BftEG7ykPXIJjTXR0_edvswq4I7CccMwFCrq3BRq4'; // Long string starting with 'eyJ...'
        
        // Initialize Supabase client
        let supabaseClient = null;
        let isSupabaseEnabled = false;
        
        if (typeof window.supabase !== 'undefined' && SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
            try {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                isSupabaseEnabled = true;
                console.log('‚úÖ Supabase connected - multi-device sync enabled');
            } catch (error) {
                console.error('‚ùå Supabase initialization failed:', error);
            }
        } else {
            console.log('‚ÑπÔ∏è Supabase not configured - using localStorage only');
        }
        
        // ====================================================================
        // APPLICATION DATA STRUCTURES
        // ====================================================================
        
        let event = {
            name: '',
            rounds: [],
            teams: [],
            scoringType: 'match', // 'match' or 'stroke'
            blowoutBonus: false,
            liveScores: {} // Structure: { roundIndex: { matchIndex: { playerName: [scores by hole] } } }
        };

        let currentLiveMatch = null;
        let currentLiveRound = null;
        let currentLiveHole = 1; // Track current hole being scored

        let teamRosters = [
            { name: 'Team USA', players: [], captain: null },
            { name: 'Team Europe', players: [], captain: null }
        ];

        // Player object structure: { name: string, phone: string }

        const formats = ['Scramble', 'Alternate Shot', 'Best Ball', 'Individual'];

        function switchTab(tabName, clickEvent) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Find and activate the clicked tab
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.textContent.toLowerCase().includes(tabName.toLowerCase()) || 
                    tab.onclick?.toString().includes(`'${tabName}'`)) {
                    tab.classList.add('active');
                }
            });
            
            document.getElementById(tabName).classList.add('active');
            
            // Recalculate points and refresh displays when switching to certain tabs
            if ((tabName === 'standings' || tabName === 'scoring') && event.teams && event.teams.length >= 2) {
                calculatePoints();
                if (tabName === 'standings') {
                    renderStandings();
                } else if (tabName === 'scoring') {
                    renderScoring();
                }
            }
        }

        function updateRoundFormats() {
            const numRounds = parseInt(document.getElementById('numRounds').value);
            const container = document.getElementById('roundFormats');
            container.innerHTML = '';

            for (let i = 1; i <= numRounds; i++) {
                const roundDiv = document.createElement('div');
                roundDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 10px;';
                roundDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-items: end; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2c3e50;">
                                Round ${i} Format
                            </label>
                            <select id="format${i}" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 4px;">
                                ${formats.map(f => `<option value="${f}">${f}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2c3e50;">
                                Date (Optional)
                            </label>
                            <input type="date" id="date${i}" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 4px;">
                        </div>
                    </div>
                    <div style="border-top: 1px solid #dee2e6; padding-top: 15px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #2c3e50;">‚õ≥ Golf Course (Optional)</label>
                        <div id="courseWidget${i}">
                            <div style="display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:center;">
                                <input type="text" id="courseLocation${i}" placeholder="City, State or ZIP (optional)"
                                    style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 4px;"
                                    onkeypress="if(event.key==='Enter') searchCourses(${i})">
                                <input type="text" id="courseSearch${i}" placeholder="Course name (full or partial)"
                                    style="padding: 10px; border: 2px solid #e0e0e0; border-radius: 4px;"
                                    onkeypress="if(event.key==='Enter') searchCourses(${i})">
                                <button class="btn btn-secondary" onclick="searchCourses(${i})" style="padding: 10px 16px; white-space: nowrap;">
                                    üîç Search
                                </button>
                            </div>
                            <div style="font-size:0.8em;color:#7f8c8d;margin-top:5px;">Enter a location, a course name, or both</div>
                            <div id="courseResults${i}" style="margin-top: 10px;"></div>
                            <div id="courseSelected${i}" style="margin-top: 10px;"></div>
                        </div>
                    </div>
                `;
                container.appendChild(roundDiv);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GOLF COURSE SEARCH & SCORECARD
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        async function callClaude(prompt) {
            const apiKey = localStorage.getItem('anthropicApiKey') || '';
            if (!apiKey) {
                throw new Error('No Anthropic API key set. Enter your key in the "Anthropic API Key" section on the Event Setup tab.');
            }
            const resp = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 2000,
                    messages: [{ role: 'user', content: prompt }]
                })
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                throw new Error(err.error?.message || `API error ${resp.status}`);
            }
            const data = await resp.json();
            const text = data.content.map(b => b.text || '').join('');
            // Strip markdown code fences if present
            return text.replace(/^```json\s*/m, '').replace(/\s*```$/m, '').trim();
        }

        function saveAnthropicKey() {
            const key = document.getElementById('anthropicApiKey').value.trim();
            if (key) {
                localStorage.setItem('anthropicApiKey', key);
            } else {
                localStorage.removeItem('anthropicApiKey');
            }
            updateAnthropicKeyStatus();
        }

        function toggleApiKeyVisibility() {
            const input = document.getElementById('anthropicApiKey');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        function updateAnthropicKeyStatus() {
            const statusEl = document.getElementById('anthropicKeyStatus');
            if (!statusEl) return;
            const key = localStorage.getItem('anthropicApiKey');
            if (key && key.startsWith('sk-ant')) {
                statusEl.innerHTML = 'ü§ñ Course Search Ready - Anthropic API key configured';
                statusEl.style.color = '#2ecc71';
            } else {
                statusEl.innerHTML = 'ü§ñ Course Search Disabled - Add Anthropic API key in Event Setup';
                statusEl.style.color = '#e67e22';
            }
        }

        async function searchCourses(roundNum) {
            const location = document.getElementById(`courseLocation${roundNum}`).value.trim();
            const name = document.getElementById(`courseSearch${roundNum}`).value.trim();
            if (!location && !name) { alert('Enter a location, a course name, or both'); return; }

            const resultsEl = document.getElementById(`courseResults${roundNum}`);

            // Build a natural prompt based on what the user provided
            let prompt, statusMsg;
            if (location && name) {
                statusMsg = `Searching for "${name}" near ${location}...`;
                prompt = `List up to 20 real golf courses that match the name "${name}" (full or partial match) ` +
                    `near or in "${location}". Include exact matches and courses with similar names. ` +
                    `Return ONLY a JSON array, no other text. Each element: ` +
                    `{"name":"Full Course Name","city":"City","state":"ST","holes":18,"type":"Public"}. ` +
                    `Order by how well the name matches first, then by proximity to the location.`;
            } else if (name) {
                statusMsg = `Searching for courses named "${name}"...`;
                prompt = `List up to 20 real golf courses whose name contains or matches "${name}" (partial match is fine). ` +
                    `Include courses from anywhere. Return ONLY a JSON array, no other text. Each element: ` +
                    `{"name":"Full Course Name","city":"City","state":"ST","holes":18,"type":"Public"}. ` +
                    `Order by how well the name matches.`;
            } else {
                statusMsg = `Searching for courses near ${location}...`;
                prompt = `List the 20 closest real golf courses to "${location}", ordered by proximity. ` +
                    `Include public, semi-private, and private courses. ` +
                    `Return ONLY a JSON array, no other text. Each element: ` +
                    `{"name":"Full Course Name","city":"City","state":"ST","holes":18,"type":"Public"}.`;
            }

            resultsEl.innerHTML = `<div style="color:#7f8c8d; padding:10px; text-align:center;">üîç ${statusMsg}</div>`;

            try {
                const raw = await callClaude(prompt);

                let courses;
                try { courses = JSON.parse(raw); } catch(e) {
                    resultsEl.innerHTML = `<div style="color:#e74c3c;padding:10px;">Could not parse course list. Try refining your search.</div>`;
                    return;
                }

                if (!Array.isArray(courses) || courses.length === 0) {
                    resultsEl.innerHTML = `<div style="color:#7f8c8d;padding:10px;">No courses found. Try a different name or location.</div>`;
                    return;
                }

                let html = `<div style="max-height:280px;overflow-y:auto;border:1px solid #dee2e6;border-radius:6px;background:white;">`;
                courses.forEach((c, idx) => {
                    html += `
                        <div onclick="selectCourse(${roundNum}, ${idx})" data-idx="${idx}"
                            style="padding:10px 14px;border-bottom:1px solid #f0f0f0;cursor:pointer;
                                   display:flex;justify-content:space-between;align-items:center;
                                   transition:background 0.15s;"
                            onmouseover="this.style.background='#f0f7ff'"
                            onmouseout="this.style.background='white'">
                            <div>
                                <div style="font-weight:600;color:#2c3e50;">${c.name}</div>
                                <div style="font-size:0.85em;color:#7f8c8d;">${c.city}, ${c.state} &bull; ${c.holes || 18} holes &bull; ${c.type || 'Golf Course'}</div>
                            </div>
                            <div style="color:#3498db;font-size:0.85em;white-space:nowrap;margin-left:10px;">Select ‚Üí</div>
                        </div>`;
                });
                html += `</div>`;

                // Store courses list on the element for selectCourse to read
                resultsEl.innerHTML = html;
                resultsEl._courses = courses;

            } catch(err) {
                console.error(err);
                resultsEl.innerHTML = `<div style="color:#e74c3c;padding:10px;">Search failed: ${err.message}</div>`;
            }
        }

        async function selectCourse(roundNum, idx) {
            const resultsEl = document.getElementById(`courseResults${roundNum}`);
            const courses = resultsEl._courses;
            if (!courses || !courses[idx]) return;
            const course = courses[idx];

            resultsEl.innerHTML = `<div style="color:#7f8c8d;padding:10px;text-align:center;">‚õ≥ Loading scorecard for ${course.name}...</div>`;

            try {
                const raw = await callClaude(
                    `Provide the scorecard for "${course.name}" in ${course.city}, ${course.state}. ` +
                    `Return ONLY a JSON object, no other text: ` +
                    `{"name":"${course.name}","city":"${course.city}","state":"${course.state}", ` +
                    `"holes":[` +
                    `{"hole":1,"par":4,"yardageBlue":380,"yardageWhite":360,"yardageRed":320,"handicap":5},` +
                    `...all 18 holes...` +
                    `]}. ` +
                    `Use real scorecard data if known. If exact data unavailable, use realistic typical values for that course type and difficulty. ` +
                    `Include all 18 holes. yardageBlue=mens back tees, yardageWhite=mens middle tees, yardageRed=forward/womens tees.`
                );

                let scorecard;
                try { scorecard = JSON.parse(raw); } catch(e) {
                    // Try to extract JSON from response
                    const match = raw.match(/\{[\s\S]*\}/);
                    if (match) {
                        try { scorecard = JSON.parse(match[0]); } catch(e2) {
                            throw new Error('Could not parse scorecard data');
                        }
                    } else {
                        throw new Error('No scorecard data returned');
                    }
                }

                if (!scorecard.holes || scorecard.holes.length !== 18) {
                    throw new Error('Incomplete scorecard (need all 18 holes)');
                }

                // Attach scorecard to the round
                const roundIndex = roundNum - 1;
                if (event.rounds && event.rounds[roundIndex]) {
                    event.rounds[roundIndex].course = scorecard;
                    saveCurrentEvent();
                } else {
                    // Store temporarily ‚Äî will be picked up when event is created
                    if (!window._pendingCourses) window._pendingCourses = {};
                    window._pendingCourses[roundIndex] = scorecard;
                }

                resultsEl.innerHTML = '';
                renderSelectedCourse(roundNum, scorecard);

            } catch(err) {
                console.error(err);
                resultsEl.innerHTML = `<div style="color:#e74c3c;padding:10px;">Failed to load scorecard: ${err.message}</div>`;
            }
        }

        function renderSelectedCourse(roundNum, course) {
            const el = document.getElementById(`courseSelected${roundNum}`);
            if (!el || !course) return;

            const totalPar = course.holes.reduce((s,h) => s + h.par, 0);
            const totalBlue = course.holes.reduce((s,h) => s + (h.yardageBlue||h.yardage||0), 0);
            const totalWhite = course.holes.reduce((s,h) => s + (h.yardageWhite||0), 0);

            let tableRows = '';
            course.holes.forEach(h => {
                tableRows += `<tr>
                    <td style="font-weight:700;text-align:center;padding:4px 6px;background:#f8f9fa;">${h.hole}</td>
                    <td style="text-align:center;padding:4px 6px;">${h.par}</td>
                    <td style="text-align:center;padding:4px 6px;color:#2980b9;">${h.yardageBlue||h.yardage||'-'}</td>
                    <td style="text-align:center;padding:4px 6px;color:#27ae60;">${h.yardageWhite||'-'}</td>
                    <td style="text-align:center;padding:4px 6px;color:#e74c3c;">${h.yardageRed||'-'}</td>
                    <td style="text-align:center;padding:4px 6px;color:#7f8c8d;">${h.handicap||'-'}</td>
                </tr>`;
            });

            el.innerHTML = `
                <div style="background:white;border:2px solid #2ecc71;border-radius:8px;padding:12px;margin-top:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                        <div>
                            <div style="font-weight:700;color:#2c3e50;font-size:1.05em;">‚úÖ ${course.name}</div>
                            <div style="color:#7f8c8d;font-size:0.85em;">${course.city}, ${course.state} &bull; Par ${totalPar} &bull; ${totalBlue} yds (Blue)</div>
                        </div>
                        <button onclick="clearCourse(${roundNum})" style="background:none;border:1px solid #e0e0e0;border-radius:4px;padding:4px 10px;cursor:pointer;color:#7f8c8d;font-size:0.85em;">‚úï Change</button>
                    </div>
                    <div style="overflow-x:auto;">
                        <table style="width:100%;border-collapse:collapse;font-size:0.82em;">
                            <thead>
                                <tr style="background:#2c3e50;color:white;">
                                    <th style="padding:5px 6px;text-align:center;">Hole</th>
                                    <th style="padding:5px 6px;text-align:center;">Par</th>
                                    <th style="padding:5px 6px;text-align:center;">Blue</th>
                                    <th style="padding:5px 6px;text-align:center;">White</th>
                                    <th style="padding:5px 6px;text-align:center;">Red</th>
                                    <th style="padding:5px 6px;text-align:center;">HCP</th>
                                </tr>
                            </thead>
                            <tbody>${tableRows}</tbody>
                            <tfoot>
                                <tr style="background:#f8f9fa;font-weight:700;">
                                    <td style="text-align:center;padding:5px 6px;">TOTAL</td>
                                    <td style="text-align:center;padding:5px 6px;">${totalPar}</td>
                                    <td style="text-align:center;padding:5px 6px;color:#2980b9;">${totalBlue}</td>
                                    <td style="text-align:center;padding:5px 6px;color:#27ae60;">${totalWhite||'-'}</td>
                                    <td style="text-align:center;padding:5px 6px;"></td>
                                    <td style="text-align:center;padding:5px 6px;"></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>`;
        }

        function clearCourse(roundNum) {
            const roundIndex = roundNum - 1;
            if (event.rounds && event.rounds[roundIndex]) {
                event.rounds[roundIndex].course = null;
                saveCurrentEvent();
            }
            document.getElementById(`courseSelected${roundNum}`).innerHTML = '';
            document.getElementById(`courseResults${roundNum}`).innerHTML = '';
            document.getElementById(`courseLocation${roundNum}`).value = '';
            document.getElementById(`courseSearch${roundNum}`).value = '';
        }

        function getCourseForRound(roundIndex) {
            if (event.rounds && event.rounds[roundIndex] && event.rounds[roundIndex].course) {
                return event.rounds[roundIndex].course;
            }
            if (window._pendingCourses && window._pendingCourses[roundIndex]) {
                return window._pendingCourses[roundIndex];
            }
            return null;
        }

                function saveEventSetup() {
            const name = document.getElementById('eventName').value.trim();
            if (!name) {
                alert('Please enter an event name');
                return;
            }
            
            event.name = name;
            event.blowoutBonus = document.getElementById('blowoutBonus').checked;
            
            // Save team names
            teamRosters[0].name = document.getElementById('team0Name').value.trim() || 'Team USA';
            teamRosters[1].name = document.getElementById('team1Name').value.trim() || 'Team Europe';
            
            // Switch to teams tab
            switchTab('teams');
        }

        function addPlayer(teamIndex) {
            const inputId = `team${teamIndex}NewPlayer`;
            const phoneId = `team${teamIndex}NewPhone`;
            const playerName = document.getElementById(inputId).value.trim();
            const playerPhone = document.getElementById(phoneId).value.trim();
            
            if (!playerName) {
                alert('Please enter a player name');
                return;
            }
            
            teamRosters[teamIndex].players.push({
                name: playerName,
                phone: playerPhone || null
            });
            
            document.getElementById(inputId).value = '';
            document.getElementById(phoneId).value = '';
            renderRoster(teamIndex);
            if (event.name) saveCurrentEvent();
        }

        function removePlayer(teamIndex, playerIndex) {
            teamRosters[teamIndex].players.splice(playerIndex, 1);
            if (teamRosters[teamIndex].captain === playerIndex) {
                teamRosters[teamIndex].captain = null;
            } else if (teamRosters[teamIndex].captain > playerIndex) {
                teamRosters[teamIndex].captain--;
            }
            renderRoster(teamIndex);
            if (event.name) saveCurrentEvent();
        }

        function setCaptain(teamIndex, playerIndex) {
            teamRosters[teamIndex].captain = playerIndex;
            renderRoster(teamIndex);
            if (event.name) saveCurrentEvent();
        }

        function renderRoster(teamIndex) {
            const roster = teamRosters[teamIndex];
            const container = document.getElementById(`team${teamIndex}Roster`);
            
            if (roster.players.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 20px;">No players added yet</p>';
                return;
            }
            
            let html = '<h4 style="margin-bottom: 15px;">Roster:</h4>';
            roster.players.forEach((player, index) => {
                const isCaptain = roster.captain === index;
                html += `
                    <div class="player-item">
                        <div style="flex: 1;">
                            <div>
                                <strong>${player.name}</strong>
                                ${isCaptain ? '<span class="captain-badge">CAPTAIN</span>' : ''}
                            </div>
                            ${player.phone ? `<div style="color: #7f8c8d; font-size: 0.9em; margin-top: 4px;">üì± ${player.phone}</div>` : ''}
                        </div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;">
                            ${player.phone ? `<button class="btn btn-secondary" onclick="sendSMS(${teamIndex}, ${index})" style="padding: 6px 12px; font-size: 14px;">üì± SMS</button>` : ''}
                            ${!isCaptain ? `<button class="btn btn-secondary" onclick="setCaptain(${teamIndex}, ${index})" style="padding: 6px 12px; font-size: 14px;">Make Captain</button>` : ''}
                            <button class="btn btn-danger" onclick="removePlayer(${teamIndex}, ${index})" style="padding: 6px 12px; font-size: 14px;">Remove</button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function renderBothRosters() {
            renderRoster(0);
            renderRoster(1);
        }

        function sendSMS(teamIndex, playerIndex) {
            const player = teamRosters[teamIndex].players[playerIndex];
            
            if (!player.phone) {
                alert('No phone number on file for this player');
                return;
            }

            if (event.teams.length === 0) {
                alert('Please create the event first before sending updates');
                return;
            }

            const message = generateEventSummary(teamIndex, playerIndex);
            const phoneNumber = player.phone.replace(/\D/g, ''); // Remove non-digits
            const smsLink = `sms:${phoneNumber}?body=${encodeURIComponent(message)}`;
            
            window.open(smsLink, '_blank');
        }

        function generateEventSummary(teamIndex, playerIndex) {
            const player = teamRosters[teamIndex].players[playerIndex];
            const team = event.teams[teamIndex];
            const opponentTeam = event.teams[teamIndex === 0 ? 1 : 0];
            
            let message = `üèÜ ${event.name}\n\n`;
            message += `You're playing for ${team.name}!\n`;
            message += `Captain: ${team.captain}\n\n`;
            
            message += `üìä CURRENT STANDINGS:\n`;
            message += `${team.name}: ${team.points} pts\n`;
            message += `${opponentTeam.name}: ${opponentTeam.points} pts\n\n`;
            
            // Find matches this player is in
            const playerMatches = [];
            event.rounds.forEach((round, dayIdx) => {
                round.matches.forEach((match, matchIdx) => {
                    const isInMatch = match.team0Players.some(p => p === player.name) || 
                                     match.team1Players.some(p => p === player.name);
                    if (isInMatch) {
                        playerMatches.push({ day, match, dayIdx });
                    }
                });
            });

            if (playerMatches.length > 0) {
                message += `üìÖ YOUR MATCHES:\n`;
                playerMatches.forEach(({ day, match }) => {
                    const isTeam0 = match.team0Players.some(p => p === player.name);
                    const teammates = isTeam0 ? match.team0Players : match.team1Players;
                    const opponents = isTeam0 ? match.team1Players : match.team0Players;
                    
                    message += `\nRound ${round.roundNumber} - ${round.format}${round.date ? ' (' + new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ')' : ''}\n`;
                    message += `${teammates.join(' & ')} vs ${opponents.join(' & ')}\n`;
                    
                    if (match.result !== null) {
                        if (match.result === 0.5) {
                            message += `Result: Tied\n`;
                        } else {
                            const didWin = (isTeam0 && match.result === 0) || (!isTeam0 && match.result === 1);
                            message += `Result: ${didWin ? 'Won' : 'Lost'}`;
                            if (match.marginOfVictory && match.holeFinished) {
                                message += ` ${match.marginOfVictory}&${19 - match.holeFinished}`;
                            }
                            if (match.blowoutBonus > 0) {
                                message += ` (+${match.blowoutBonus.toFixed(2)} bonus!)`;
                            }
                            message += `\n`;
                        }
                    } else {
                        message += `Result: Not played yet\n`;
                    }
                });
            }
            
            message += `\n‚õ≥ Good luck!`;
            
            return message;
        }

        function renderLiveScoreboard() {
            let html = `
                <div style="background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: white; padding: 25px; border-radius: 12px; margin-bottom: 30px;">
                    <h2 style="margin-bottom: 20px; text-align: center;">üìä Live Scoreboard</h2>
            `;

            let hasAnyScores = false;

            event.rounds.forEach((round, roundIndex) => {
                const roundHasScores = round.matches.some(match => {
                    const liveData = getLiveMatchData(roundIndex, round.matches.indexOf(match));
                    return liveData.hasScores;
                });

                if (roundHasScores) {
                    hasAnyScores = true;
                    html += `
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h3 style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid rgba(255,255,255,0.3);">
                                Round ${round.roundNumber} - ${round.format}${round.date ? ' (' + new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ')' : ''}
                            </h3>
                    `;

                    round.matches.forEach((match, matchIndex) => {
                        const liveData = getLiveMatchData(roundIndex, matchIndex);
                        
                        if (liveData.hasScores) {
                            let status = '';
                            let statusColor = '#95a5a6';
                            
                            if (event.scoringType === 'stroke') {
                                const team0Total = liveData.team0Total || 0;
                                const team1Total = liveData.team1Total || 0;
                                const diff = Math.abs(team0Total - team1Total);
                                
                                if (team0Total === 0 && team1Total === 0) {
                                    status = 'Not started';
                                } else if (team0Total === team1Total) {
                                    status = 'All Square';
                                    statusColor = '#f39c12';
                                } else if (team0Total < team1Total) {
                                    status = `${event.teams[0].name} leads by ${diff}`;
                                    statusColor = '#3498db';
                                } else {
                                    status = `${event.teams[1].name} leads by ${diff}`;
                                    statusColor = '#e74c3c';
                                }
                            } else {
                                // Match play
                                const matchPlayResult = calculateMatchPlayResult(liveData);
                                const holesPlayed = matchPlayResult.holeFinished || 0;
                                const holesRemaining = 18 - holesPlayed;
                                
                                if (matchPlayResult.margin === 0) {
                                    status = `All Square through ${holesPlayed}`;
                                    statusColor = '#f39c12';
                                } else if (matchPlayResult.result === 0) {
                                    if (matchPlayResult.margin > holesRemaining) {
                                        // Match is over
                                        if (holesRemaining === 0) {
                                            status = `${event.teams[0].name} wins ${matchPlayResult.margin} Up`;
                                        } else {
                                            status = `${event.teams[0].name} wins ${matchPlayResult.margin}&${holesRemaining}`;
                                        }
                                        statusColor = '#2ecc71';
                                    } else {
                                        status = `${event.teams[0].name} ${matchPlayResult.margin} up through ${holesPlayed}`;
                                        statusColor = '#3498db';
                                    }
                                } else if (matchPlayResult.result === 1) {
                                    if (matchPlayResult.margin > holesRemaining) {
                                        // Match is over
                                        if (holesRemaining === 0) {
                                            status = `${event.teams[1].name} wins ${matchPlayResult.margin} Up`;
                                        } else {
                                            status = `${event.teams[1].name} wins ${matchPlayResult.margin}&${holesRemaining}`;
                                        }
                                        statusColor = '#2ecc71';
                                    } else {
                                        status = `${event.teams[1].name} ${matchPlayResult.margin} up through ${holesPlayed}`;
                                        statusColor = '#e74c3c';
                                    }
                                }
                            }

                            html += `
                                <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="font-weight: 600; margin-bottom: 5px;">Match ${matchIndex + 1}</div>
                                            <div style="font-size: 0.9em; opacity: 0.9;">
                                                ${match.team0Players.join(' & ')} vs ${match.team1Players.join(' & ')}
                                            </div>
                                        </div>
                                        <div style="text-align: right; padding: 8px 15px; background: ${statusColor}; border-radius: 20px; font-weight: 600; font-size: 0.95em;">
                                            ${status}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    });

                    html += `</div>`;
                }
            });

            if (!hasAnyScores) {
                html += `
                    <div style="text-align: center; padding: 30px; opacity: 0.7;">
                        <div style="font-size: 3em; margin-bottom: 10px;">‚õ≥</div>
                        <div style="font-size: 1.1em;">No scores entered yet</div>
                        <div style="font-size: 0.9em; margin-top: 5px;">Select a match below to start scoring</div>
                    </div>
                `;
            }

            html += `</div>`;
            return html;
        }

        function renderLiveScoring() {
            const container = document.getElementById('liveContent');
            
            if (event.teams.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì±</div>
                        <h3>No Event Created</h3>
                        <p>Create an event to enable live scoring</p>
                    </div>
                `;
                return;
            }

            let html = `
                <div class="live-header">
                    <h2 style="margin-bottom: 10px;">üì± Live Scoring</h2>
                    <p>Enter scores hole-by-hole on the course</p>
                </div>
            `;

            // Match selection
            if (currentLiveMatch === null || currentLiveRound === null) {
                html += `
                    <div class="player-selector">
                        <h3 style="margin-bottom: 15px;">Select Match to Score</h3>
                        <div style="display: grid; gap: 10px;">
                `;

                if (event.rounds && event.rounds.length > 0) {
                    event.rounds.forEach((round, roundIndex) => {
                        if (round.matches && round.matches.length > 0) {
                            round.matches.forEach((match, matchIndex) => {
                        const liveData = getLiveMatchData(roundIndex, matchIndex);
                        const hasScores = liveData.hasScores;
                        
                        html += `
                            <button class="btn ${hasScores ? 'btn-secondary' : ''}" onclick="selectLiveMatch(${roundIndex}, ${matchIndex})" 
                                    style="padding: 20px; font-size: 1.1em; text-align: left;">
                                <div style="font-weight: 600; margin-bottom: 5px;">Round ${round.roundNumber} - ${round.format}${round.date ? ' (' + new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ')' : ''}</div>
                                <div style="font-size: 0.9em; opacity: 0.9;">
                                    ${match.team0Players.join(' & ')} vs ${match.team1Players.join(' & ')}
                                </div>
                                ${hasScores ? '<div style="font-size: 0.85em; margin-top: 5px; color: #2ecc71;">‚úì Scores in progress</div>' : ''}
                            </button>
                        `;
                            });
                        }
                    });
                }

                html += `
                        </div>
                    </div>
                `;
            } else {
                // Show scoring interface for the match
                html += renderMatchScoring();
            }

            container.innerHTML = html;
        }

        function renderMatchScoring() {
            const round = event.rounds[currentLiveRound];
            if (!round || !round.matches || !round.matches[currentLiveMatch]) {
                console.error('Invalid round or match index', currentLiveRound, currentLiveMatch);
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <h3>Match Not Found</h3>
                        <p>Please select a match to begin live scoring</p>
                        <button class="btn" onclick="currentLiveMatch = null; currentLiveRound = null; renderLiveScoring();">
                            Back to Match Selection
                        </button>
                    </div>
                `;
            }
            const match = round.matches[currentLiveMatch];
            
            // Initialize scores for all players if needed
            if (!event.liveScores[currentLiveRound]) {
                event.liveScores[currentLiveRound] = {};
            }
            if (!event.liveScores[currentLiveRound][currentLiveMatch]) {
                event.liveScores[currentLiveRound][currentLiveMatch] = {};
            }

            const allPlayers = [...match.team0Players, ...match.team1Players];
            allPlayers.forEach(player => {
                if (!event.liveScores[currentLiveRound][currentLiveMatch][player]) {
                    event.liveScores[currentLiveRound][currentLiveMatch][player] = Array(18).fill(null);
                }
            });

            // Calculate current match status
            const liveData = getLiveMatchData(currentLiveRound, currentLiveMatch);
            let matchStatus = '';
            
            if (liveData.hasScores) {
                if (event.scoringType === 'stroke') {
                    const team0Total = liveData.team0Total || 0;
                    const team1Total = liveData.team1Total || 0;
                    const diff = Math.abs(team0Total - team1Total);
                    
                    if (team0Total === 0 && team1Total === 0) {
                        matchStatus = '';
                    } else if (team0Total === team1Total) {
                        matchStatus = 'All Square';
                    } else if (team0Total < team1Total) {
                        matchStatus = `${event.teams[0].name} leads by ${diff} strokes`;
                    } else {
                        matchStatus = `${event.teams[1].name} leads by ${diff} strokes`;
                    }
                } else {
                    // Match play
                    const matchPlayResult = calculateMatchPlayResult(liveData);
                    const holesPlayed = matchPlayResult.holeFinished || 0;
                    const holesRemaining = 18 - holesPlayed;
                    
                    if (matchPlayResult.margin === 0) {
                        matchStatus = 'All Square';
                    } else if (matchPlayResult.result === 0) {
                        if (matchPlayResult.margin > holesRemaining) {
                            // Match is over
                            if (holesRemaining === 0) {
                                matchStatus = `${event.teams[0].name} wins ${matchPlayResult.margin} Up`;
                            } else {
                                matchStatus = `${event.teams[0].name} wins ${matchPlayResult.margin}&${holesRemaining}`;
                            }
                        } else {
                            matchStatus = `${event.teams[0].name} ${matchPlayResult.margin} up`;
                        }
                    } else if (matchPlayResult.result === 1) {
                        if (matchPlayResult.margin > holesRemaining) {
                            // Match is over
                            if (holesRemaining === 0) {
                                matchStatus = `${event.teams[1].name} wins ${matchPlayResult.margin} Up`;
                            } else {
                                matchStatus = `${event.teams[1].name} wins ${matchPlayResult.margin}&${holesRemaining}`;
                            }
                        } else {
                            matchStatus = `${event.teams[1].name} ${matchPlayResult.margin} up`;
                        }
                    }
                }
            }

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <button class="btn btn-secondary" onclick="exitLiveScoring()">‚Üê Back to Matches</button>
                    <div style="text-align: right;">
                        <div style="font-weight: 600; color: #2c3e50;">Round ${round.roundNumber} - ${round.format}${round.date ? ' (' + new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ')' : ''}</div>
                        ${(() => { const c = getCourseForRound(currentLiveRound); return c ? `<div style="font-size:0.85em;color:#27ae60;font-weight:600;">‚õ≥ ${c.name}</div>` : ''; })()}
                        <div style="font-size: 0.9em; color: #7f8c8d;">${match.team0Players.join(' & ')} vs ${match.team1Players.join(' & ')}</div>
                    </div>
                </div>
            `;

            // Match status
            if (matchStatus) {
                html += `
                    <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border-radius: 8px; font-weight: 600; font-size: 1.2em; margin-bottom: 20px;">
                        ${matchStatus}
                    </div>
                `;
            }

            // Hole navigation
            html += `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <button class="btn btn-secondary" onclick="changeHole(-1)" ${currentLiveHole === 1 ? 'disabled' : ''} style="padding: 10px 20px;">
                            ‚Üê Previous
                        </button>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5em; font-weight: 700; color: #2c3e50;">
                                Hole ${currentLiveHole}
                            </div>
                            ${(() => {
                                const course = getCourseForRound(currentLiveRound);
                                if (!course) return '';
                                const holeData = course.holes[currentLiveHole - 1];
                                if (!holeData) return '';
                                const yds = holeData.yardageBlue || holeData.yardage || holeData.yardageWhite || '';
                                return `<div style="display:flex;gap:10px;justify-content:center;margin-top:4px;">
                                    <span style="background:#2c3e50;color:white;padding:2px 10px;border-radius:12px;font-size:0.85em;font-weight:700;">Par ${holeData.par}</span>
                                    ${yds ? `<span style="background:#2980b9;color:white;padding:2px 10px;border-radius:12px;font-size:0.85em;">${yds} yds</span>` : ''}
                                    ${holeData.handicap ? `<span style="background:#7f8c8d;color:white;padding:2px 10px;border-radius:12px;font-size:0.85em;">HCP ${holeData.handicap}</span>` : ''}
                                </div>`;
                            })()}
                        </div>
                        <button class="btn btn-secondary" onclick="changeHole(1)" ${currentLiveHole === 18 ? 'disabled' : ''} style="padding: 10px 20px;">
                            Next ‚Üí
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(9, 1fr); gap: 5px; margin-bottom: 10px;">
            `;

            // Hole selector buttons (1-9)
            for (let i = 1; i <= 9; i++) {
                const isActive = i === currentLiveHole;
                const allScored = allPlayers.every(p => 
                    event.liveScores[currentLiveRound][currentLiveMatch][p][i-1] !== null
                );
                html += `
                    <button onclick="jumpToHole(${i})" 
                            style="padding: 10px; border: 2px solid ${isActive ? '#3498db' : '#e0e0e0'}; 
                                   background: ${allScored ? '#2ecc71' : isActive ? '#3498db' : 'white'}; 
                                   color: ${allScored || isActive ? 'white' : '#2c3e50'}; 
                                   border-radius: 4px; cursor: pointer; font-weight: ${isActive ? '700' : '600'};">
                        ${i}
                    </button>
                `;
            }

            html += `
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(9, 1fr); gap: 5px;">
            `;

            // Hole selector buttons (10-18)
            for (let i = 10; i <= 18; i++) {
                const isActive = i === currentLiveHole;
                const allScored = allPlayers.every(p => 
                    event.liveScores[currentLiveRound][currentLiveMatch][p][i-1] !== null
                );
                html += `
                    <button onclick="jumpToHole(${i})" 
                            style="padding: 10px; border: 2px solid ${isActive ? '#3498db' : '#e0e0e0'}; 
                                   background: ${allScored ? '#2ecc71' : isActive ? '#3498db' : 'white'}; 
                                   color: ${allScored || isActive ? 'white' : '#2c3e50'}; 
                                   border-radius: 4px; cursor: pointer; font-weight: ${isActive ? '700' : '600'};">
                        ${i}
                    </button>
                `;
            }

            html += `
                    </div>
                </div>
            `;

            // Player scoring cards
            html += `<div style="display: grid; gap: 15px;">`;

            const isScramble = round.format === 'Scramble';

            // Team 0 players
            html += `<div style="background: #ebf5fb; border: 3px solid #3498db; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #3498db; margin-bottom: 15px; text-align: center;">${event.teams[0].name}</h3>`;
            
            if (isScramble) {
                // For scramble, show team score once
                const teamPlayers = match.team0Players.join(' & ');
                // Use first player's scores as the team score
                const scores = event.liveScores[currentLiveRound][currentLiveMatch][match.team0Players[0]];
                const currentScore = scores[currentLiveHole - 1];
                const total = scores.reduce((sum, s) => sum + (s || 0), 0);
                const holesScored = scores.filter(s => s !== null).length;

                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 600; font-size: 1.1em; color: #2c3e50;">${teamPlayers}</div>
                                <div style="font-size: 0.9em; color: #7f8c8d;">Team Total: ${total} (${holesScored} holes)</div>
                            </div>
                            ${currentScore !== null ? `
                                <div style="background: #3498db; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 700; font-size: 1.2em;">
                                    Hole ${currentLiveHole}: ${currentScore}
                                </div>
                            ` : `
                                <div style="background: #ecf0f1; color: #7f8c8d; padding: 8px 16px; border-radius: 8px; font-weight: 600; font-size: 1em;">
                                    Hole ${currentLiveHole}: -
                                </div>
                            `}
                        </div>
                        <div class="score-buttons">
                            ${[2,3,4,5,6,7,8].map(score => `
                                <button class="score-btn ${currentScore === score ? 'selected' : ''}" 
                                        onclick="recordTeamScore(0, ${currentLiveHole}, ${score})">
                                    ${score}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                // Individual scores for each player
                match.team0Players.forEach(player => {
                    const scores = event.liveScores[currentLiveRound][currentLiveMatch][player];
                    const currentScore = scores[currentLiveHole - 1];
                    const total = scores.reduce((sum, s) => sum + (s || 0), 0);
                    const holesScored = scores.filter(s => s !== null).length;

                    html += `
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 1.1em; color: #2c3e50;">${player}</div>
                                    <div style="font-size: 0.9em; color: #7f8c8d;">Total: ${total} (${holesScored} holes)</div>
                                ${currentScore !== null ? `
                                    <div style="background: #3498db; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 700; font-size: 1.2em;">
                                        Hole ${currentLiveHole}: ${currentScore}
                                    </div>
                                ` : `
                                    <div style="background: #ecf0f1; color: #7f8c8d; padding: 8px 16px; border-radius: 8px; font-weight: 600; font-size: 1em;">
                                        Hole ${currentLiveHole}: -
                                    </div>
                                `}
                                </div>
                            </div>
                            <div class="score-buttons">
                                ${[2,3,4,5,6,7,8].map(score => `
                                    <button class="score-btn ${currentScore === score ? 'selected' : ''}" 
                                            onclick="recordPlayerScore('${player}', ${currentLiveHole}, ${score})">
                                        ${score}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
            }

            html += `</div>`;

            // Team 1 players
            html += `<div style="background: #fadbd8; border: 3px solid #e74c3c; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #e74c3c; margin-bottom: 15px; text-align: center;">${event.teams[1].name}</h3>`;
            
            if (isScramble) {
                // For scramble, show team score once
                const teamPlayers = match.team1Players.join(' & ');
                // Use first player's scores as the team score
                const scores = event.liveScores[currentLiveRound][currentLiveMatch][match.team1Players[0]];
                const currentScore = scores[currentLiveHole - 1];
                const total = scores.reduce((sum, s) => sum + (s || 0), 0);
                const holesScored = scores.filter(s => s !== null).length;

                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-weight: 600; font-size: 1.1em; color: #2c3e50;">${teamPlayers}</div>
                                <div style="font-size: 0.9em; color: #7f8c8d;">Team Total: ${total} (${holesScored} holes)</div>
                            </div>
                        </div>
                        <div class="score-buttons">
                            ${[2,3,4,5,6,7,8].map(score => `
                                <button class="score-btn ${currentScore === score ? 'selected' : ''}" 
                                        onclick="recordTeamScore(1, ${currentLiveHole}, ${score})">
                                    ${score}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                `;
            } else {
                // Individual scores for each player
                match.team1Players.forEach(player => {
                    const scores = event.liveScores[currentLiveRound][currentLiveMatch][player];
                    const currentScore = scores[currentLiveHole - 1];
                    const total = scores.reduce((sum, s) => sum + (s || 0), 0);
                    const holesScored = scores.filter(s => s !== null).length;

                    html += `
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 1.1em; color: #2c3e50;">${player}</div>
                                    <div style="font-size: 0.9em; color: #7f8c8d;">Total: ${total} (${holesScored} holes)</div>
                                </div>
                            </div>
                            <div class="score-buttons">
                                ${[2,3,4,5,6,7,8].map(score => `
                                    <button class="score-btn ${currentScore === score ? 'selected' : ''}" 
                                            onclick="recordPlayerScore('${player}', ${currentLiveHole}, ${score})">
                                        ${score}
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
            }

            html += `</div></div>`;

            return html;
        }
        function selectLiveMatch(roundIndex, matchIndex) {
            currentLiveRound = roundIndex;
            currentLiveMatch = matchIndex;
            currentLiveHole = 1;
            renderLiveScoring();
        }

        function exitLiveScoring() {
            currentLiveMatch = null;
            currentLiveRound = null;
            currentLiveHole = 1;
            renderLiveScoring();
        }

        function changeHole(direction) {
            currentLiveHole = Math.max(1, Math.min(18, currentLiveHole + direction));
            renderLiveScoring();
        }

        function jumpToHole(holeNumber) {
            currentLiveHole = holeNumber;
            renderLiveScoring();
        }

        function recordPlayerScore(playerName, holeNumber, score) {
            const scores = event.liveScores[currentLiveRound][currentLiveMatch][playerName];
            scores[holeNumber - 1] = score;
            
            // Recalculate match results from live scores
            calculatePoints();
            
            // Update all views to show live changes
            renderLiveScoring();
            renderScoring();
            renderStandings();
            renderLiveScoreboardTab();
            saveCurrentEvent();
        }

        function recordTeamScore(teamIndex, holeNumber, score) {
            // For scramble, record the same score for all players on the team
            const match = event.rounds[currentLiveRound].matches[currentLiveMatch];
            const teamPlayers = teamIndex === 0 ? match.team0Players : match.team1Players;
            
            teamPlayers.forEach(player => {
                const scores = event.liveScores[currentLiveRound][currentLiveMatch][player];
                scores[holeNumber - 1] = score;
            });
            
            // Recalculate match results from live scores
            calculatePoints();
            
            // Update all views to show live changes
            renderLiveScoring();
            renderScoring();
            renderStandings();
            renderLiveScoreboardTab();
            saveCurrentEvent();
        }

        function getLiveMatchData(roundIndex, matchIndex) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            const liveData = {
                hasScores: false,
                team0Total: null,
                team1Total: null,
                team0Players: {},
                team1Players: {}
            };

            if (!event.liveScores[roundIndex] || !event.liveScores[roundIndex][matchIndex]) {
                return liveData;
            }

            const matchScores = event.liveScores[roundIndex][matchIndex];

            // Check if any player has scores
            const hasAnyScores = Object.keys(matchScores).some(player => 
                matchScores[player].some(score => score !== null)
            );

            if (!hasAnyScores) {
                return liveData;
            }

            liveData.hasScores = true;

            // Calculate totals for each team
            match.team0Players.forEach(player => {
                if (matchScores[player]) {
                    const playerTotal = matchScores[player].reduce((sum, score) => 
                        sum + (score !== null ? score : 0), 0
                    );
                    liveData.team0Players[player] = {
                        scores: matchScores[player],
                        total: playerTotal
                    };
                }
            });

            match.team1Players.forEach(player => {
                if (matchScores[player]) {
                    const playerTotal = matchScores[player].reduce((sum, score) => 
                        sum + (score !== null ? score : 0), 0
                    );
                    liveData.team1Players[player] = {
                        scores: matchScores[player],
                        total: playerTotal
                    };
                }
            });

            // Calculate stroke totals for both teams (always, regardless of scoring type)
            const team0Totals = Object.values(liveData.team0Players).map(p => p.total);
            const team1Totals = Object.values(liveData.team1Players).map(p => p.total);
            
            // Use best score for team formats (scramble), individual score for singles
            if (match.team0Players.length === 1 && match.team1Players.length === 1) {
                liveData.team0Total = team0Totals[0] || null;
                liveData.team1Total = team1Totals[0] || null;
            } else {
                liveData.team0Total = team0Totals.length > 0 ? Math.min(...team0Totals) : null;
                liveData.team1Total = team1Totals.length > 0 ? Math.min(...team1Totals) : null;
            }

            return liveData;
        }

        function calculateMatchPlayResult(liveData) {
            // For match play, calculate hole-by-hole who's winning
            const result = {
                result: null,
                margin: 0,
                holeFinished: null,
                isComplete: false  // true only when match is genuinely over
            };

            const team0Players = Object.values(liveData.team0Players);
            const team1Players = Object.values(liveData.team1Players);

            if (team0Players.length === 0 || team1Players.length === 0) {
                return result;
            }

            // Get best ball scores per hole for each team
            let team0Up = 0;
            let lastCompletedHole = 0;

            for (let hole = 0; hole < 18; hole++) {
                const team0HoleScores = team0Players
                    .map(p => p.scores[hole])
                    .filter(s => s !== null);
                const team1HoleScores = team1Players
                    .map(p => p.scores[hole])
                    .filter(s => s !== null);

                if (team0HoleScores.length === 0 || team1HoleScores.length === 0) {
                    // Not all scores entered yet for this hole
                    break;
                }

                lastCompletedHole = hole + 1;
                const team0BestScore = Math.min(...team0HoleScores);
                const team1BestScore = Math.min(...team1HoleScores);

                if (team0BestScore < team1BestScore) {
                    team0Up++;
                } else if (team1BestScore < team0BestScore) {
                    team0Up--;
                }

                // Check if match is over
                const holesRemaining = 18 - (hole + 1);
                if (Math.abs(team0Up) > holesRemaining) {
                    result.holeFinished = hole + 1;
                    result.margin = Math.abs(team0Up);
                    result.result = team0Up > 0 ? 0 : 1;
                    result.isComplete = true;  // closed out early ‚Äî match is over
                    return result;
                }
            }

            // Set the current status (match in progress or completed)
            result.holeFinished = lastCompletedHole;
            result.margin = Math.abs(team0Up);
            
            if (lastCompletedHole === 18) {
                // All 18 holes complete ‚Äî match is finished
                result.isComplete = true;
                if (team0Up > 0) {
                    result.result = 0;
                } else if (team0Up < 0) {
                    result.result = 1;
                } else {
                    result.result = 0.5; // Tie
                }
            } else if (team0Up > 0) {
                result.result = 0; // Team 0 leading (in progress)
            } else if (team0Up < 0) {
                result.result = 1; // Team 1 leading (in progress)
            } else {
                result.result = 0.5; // All square (in progress)
            }

            return result;
        }

        function clearAllData(skipHTMLClear = false) {
            // Clear all event data
            event = {
                name: '',
                scoringType: 'match',
                blowoutBonus: false,
                teams: [],
                rounds: [],
                liveScores: {}
            };
            
            // Clear team rosters
            teamRosters = [
                { name: '', players: [], captain: null },
                { name: '', players: [], captain: null }
            ];
            
            // Clear live scoring state
            currentLiveRound = null;
            currentLiveMatch = null;
            currentLiveHole = 1;
            
            // Clear all rendered content (unless we're about to re-render immediately)
            if (!skipHTMLClear) {
                document.getElementById('matchupsContent').innerHTML = '';
                document.getElementById('scoringContent').innerHTML = '';
                document.getElementById('liveContent').innerHTML = '';
                document.getElementById('standingsContent').innerHTML = '';
                document.getElementById('liveScoreboardContent').innerHTML = '';
            }
            
            console.log('All data cleared', skipHTMLClear ? '(HTML preserved)' : '');
        }

        function createGolfEvent() {
            const name = document.getElementById('eventName').value.trim();
            const numRounds = parseInt(document.getElementById('numRounds').value);
            const scoringType = document.getElementById('scoringType').value;
            
            const team0Name = document.getElementById('team0Name').value.trim();
            const team1Name = document.getElementById('team1Name').value.trim();

            if (!team0Name || !team1Name) {
                alert('Please enter both team names');
                return;
            }

            if (teamRosters[0].players.length === 0 || teamRosters[1].players.length === 0) {
                alert('Please add players to both teams');
                return;
            }

            if (teamRosters[0].captain === null || teamRosters[1].captain === null) {
                alert('Please select a captain for each team');
                return;
            }

            // Check if event name already exists (unless we're editing the current event)
            const savedEvents = getSavedEvents();
            const existingEvent = savedEvents.find(e => 
                e.name.toLowerCase() === name.toLowerCase() && 
                e.id !== event.id  // Allow updating current event
            );
            
            if (existingEvent) {
                alert(`An event named "${name}" already exists. Please choose a different name.`);
                return;
            }

            // SAVE team roster data before clearing (we need it!)
            const savedTeamRosters = JSON.parse(JSON.stringify(teamRosters));
            
            // CLEAR ALL STALE DATA (event, liveScores, and old HTML)
            clearAllData();  // Clear everything including old HTML
            
            // RESTORE team rosters (we just created these)
            teamRosters = savedTeamRosters;

            // Update team names in case they were changed
            teamRosters[0].name = team0Name;
            teamRosters[1].name = team1Name;

            event.name = name;
            event.scoringType = scoringType;
            event.blowoutBonus = document.getElementById('blowoutBonus').checked && scoringType === 'match';
            event.teams = [
                { 
                    name: team0Name, 
                    captain: teamRosters[0].players[teamRosters[0].captain].name, 
                    players: teamRosters[0].players.map(p => p.name), 
                    points: 0 
                },
                { 
                    name: team1Name, 
                    captain: teamRosters[1].players[teamRosters[1].captain].name, 
                    players: teamRosters[1].players.map(p => p.name), 
                    points: 0 
                }
            ];

            // Initialize days with empty matches
            event.rounds = [];
            for (let i = 1; i <= numRounds; i++) {
                const format = document.getElementById(`format${i}`).value;
                const date = document.getElementById(`date${i}`).value;
                // Preserve course: check existing rounds, then pending (searched before event created)
                const existingRound = event.rounds && event.rounds[i - 1];
                const course = (existingRound && existingRound.course)
                    || (window._pendingCourses && window._pendingCourses[i - 1])
                    || null;
                event.rounds.push({
                    roundNumber: i,
                    format: format,
                    date: date || null,
                    course: course,
                    matches: []
                });
            }

            renderMatchups();
            switchTab('matchups');
            saveCurrentEvent();
            alert('Event created! Now set up matchups for each round.');
        }

        function renderMatchups() {
            const container = document.getElementById('matchupsContent');
            
            console.log('renderMatchups called');
            console.log('event.teams:', event.teams);
            console.log('event.rounds:', event.rounds);
            
            if (event.teams.length === 0) {
                console.log('No teams - showing empty state');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üë•</div>
                        <h3>No Event Created</h3>
                        <p>Create an event to set up matchups</p>
                    </div>
                `;
                return;
            }

            let html = `<h2 style="margin-bottom: 20px;">Configure Matchups</h2>`;

            event.rounds.forEach((round, roundIndex) => {
                const dateDisplay = round.date ? ` - ${new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}` : '';
                html += `
                    <div class="round-card">
                        <div class="round-header">
                            <h3>Round ${round.roundNumber}: ${round.format}${dateDisplay}</h3>
                        </div>
                        
                        <div id="matchupsDay${roundIndex}">
                `;

                // Show existing matches
                round.matches.forEach((match, matchIndex) => {
                    html += `
                        <div class="match-card" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong>Match ${matchIndex + 1}</strong>
                                <button class="btn btn-danger" onclick="deleteMatch(${roundIndex}, ${matchIndex})" style="padding: 6px 12px; font-size: 14px;">Delete</button>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center;">
                                <div style="background: #ebf5fb; border: 2px solid #3498db; padding: 15px; border-radius: 8px;">
                                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">${event.teams[0].name}</div>
                                    <div>${match.team0Players.join(', ')}</div>
                                </div>
                                <div style="font-size: 1.5em; font-weight: 600; color: #95a5a6;">VS</div>
                                <div style="background: #fadbd8; border: 2px solid #e74c3c; padding: 15px; border-radius: 8px;">
                                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">${event.teams[1].name}</div>
                                    <div>${match.team1Players.join(', ')}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                // Add new match form
                html += `
                        </div>
                        
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 15px;">
                            <h4 style="margin-bottom: 15px;">Add New Match</h4>
                            <div class="team-setup">
                                <div class="team-card team-0">
                                    <h4 style="margin-bottom: 10px;">${event.teams[0].name} Players</h4>
                                    <div id="team0Select${roundIndex}">
                `;

                const usedTeam0Players = round.matches.flatMap(m => m.team0Players);
                event.teams[0].players.forEach(player => {
                    const isUsed = usedTeam0Players.includes(player);
                    html += `
                        <label style="display: block; margin-bottom: 8px; ${isUsed ? 'opacity: 0.5;' : ''}">
                            <input type="checkbox" 
                                   id="team0_${roundIndex}_${player}" 
                                   value="${player}"
                                   ${isUsed ? 'disabled' : ''}
                                   style="margin-right: 8px;">
                            ${player} ${isUsed ? '(already in match)' : ''}
                        </label>
                    `;
                });

                html += `
                                    </div>
                                </div>
                                
                                <div class="team-card team-1">
                                    <h4 style="margin-bottom: 10px;">${event.teams[1].name} Players</h4>
                                    <div id="team1Select${roundIndex}">
                `;

                const usedTeam1Players = round.matches.flatMap(m => m.team1Players);
                event.teams[1].players.forEach(player => {
                    const isUsed = usedTeam1Players.includes(player);
                    html += `
                        <label style="display: block; margin-bottom: 8px; ${isUsed ? 'opacity: 0.5;' : ''}">
                            <input type="checkbox" 
                                   id="team1_${roundIndex}_${player}" 
                                   value="${player}"
                                   ${isUsed ? 'disabled' : ''}
                                   style="margin-right: 8px;">
                            ${player} ${isUsed ? '(already in match)' : ''}
                        </label>
                    `;
                });

                html += `
                                    </div>
                                </div>
                            </div>
                            <button class="btn" onclick="addMatch(${roundIndex})" style="margin-top: 15px; width: 100%;">Add Match</button>
                        </div>
                    </div>
                `;
            });

            html += `<button class="btn" onclick="finalizeMatchups()" style="margin-top: 20px; width: 100%;">Finalize Matchups & Start Scoring</button>`;

            container.innerHTML = html;
        }

        function addMatch(roundIndex) {
            const round = event.rounds[roundIndex];
            const team0Selected = [];
            const team1Selected = [];

            // Get selected players from team 0
            event.teams[0].players.forEach(player => {
                const checkbox = document.getElementById(`team0_${roundIndex}_${player}`);
                if (checkbox && checkbox.checked) {
                    team0Selected.push(player);
                }
            });

            // Get selected players from team 1
            event.teams[1].players.forEach(player => {
                const checkbox = document.getElementById(`team1_${roundIndex}_${player}`);
                if (checkbox && checkbox.checked) {
                    team1Selected.push(player);
                }
            });

            if (team0Selected.length === 0 || team1Selected.length === 0) {
                alert('Please select at least one player from each team');
                return;
            }

            // Add the match
            round.matches.push({
                format: round.format,
                team0Players: team0Selected,
                team1Players: team1Selected,
                team0Score: null,
                team1Score: null,
                result: null,
                holeFinished: null,
                marginOfVictory: null,
                blowoutBonus: 0
            });

            renderMatchups();
        }

        function deleteMatch(roundIndex, matchIndex) {
            event.rounds[roundIndex].matches.splice(matchIndex, 1);
            renderMatchups();
        }

        function finalizeMatchups() {
            // Check that all days have at least one match
            const roundsWithoutMatches = event.rounds.filter(d => d.matches.length === 0);
            if (roundsWithoutMatches.length > 0) {
                const roundNumbers = roundsWithoutMatches.map(d => d.roundNumber).join(', ');
                if (!confirm(`Round(s) ${roundNumbers} have no matches. Continue anyway?`)) {
                    return;
                }
            }

            renderScoring();
            renderLiveScoring();
            renderLiveScoreboardTab();
            saveCurrentEvent();
            switchTab('scoring');
            alert('Matchups finalized! Enter scores in the Scoring tab.');
        }

        function renderLiveScoreboardTab() {
            const container = document.getElementById('liveScoreboardContent');
            
            if (event.teams.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìä</div>
                        <h3>No Event Created</h3>
                        <p>Create an event to see live scores</p>
                    </div>
                `;
                return;
            }

            let html = `
                <div style="text-align: center; margin-bottom: 30px;">
                    <h1 style="font-size: 2.5em; margin-bottom: 10px;">üìä Live Scoreboard</h1>
                    <p style="font-size: 1.2em; color: #7f8c8d;">${event.name}</p>
                </div>
            `;

            html += renderLiveScoreboard();
            container.innerHTML = html;
        }

        function renderScoring() {
            const container = document.getElementById('scoringContent');
            
            if (event.teams.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üèåÔ∏è</div>
                        <h3>No Event Created</h3>
                        <p>Complete setup to start scoring matches</p>
                    </div>
                `;
                return;
            }

            let html = `<h2 style="margin-bottom: 20px;">${event.name}</h2>`;

            event.rounds.forEach((round, roundIndex) => {
                const dateDisplay = round.date ? ` - ${new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}` : '';
                
                html += `
                    <div class="round-card" style="margin-bottom: 30px;">
                        <div class="round-header">
                            <h3>Round ${round.roundNumber}: ${round.format}${dateDisplay}</h3>
                        </div>
                        <div style="background: white; border-radius: 8px; overflow: hidden;">
                `;

                round.matches.forEach((match, matchIndex) => {
                    const isStrokePlay = event.scoringType === 'stroke';
                    const liveData = getLiveMatchData(roundIndex, matchIndex);
                    const hasLiveScores = liveData.hasScores;
                    
                    // Calculate scores from live data if available - ALWAYS show totals
                    let team0Score = hasLiveScores && liveData.team0Total !== null ? liveData.team0Total : match.team0Score;
                    let team1Score = hasLiveScores && liveData.team1Total !== null ? liveData.team1Total : match.team1Score;
                    
                    // Calculate match result and points
                    let matchResult = match.result;
                    let team0Points = 0;
                    let team1Points = 0;
                    let matchComplete = false;
                    
                    if (hasLiveScores && isStrokePlay) {
                        match.team0Score = team0Score;
                        match.team1Score = team1Score;
                        
                        // Check if all 18 holes are played
                        let holesScored = 0;
                        if (liveData.scores && Object.keys(liveData.scores).length > 0) {
                            holesScored = Object.values(liveData.scores[Object.keys(liveData.scores)[0]] || {}).filter(s => s !== null).length;
                        }
                        
                        if (team0Score !== null && team1Score !== null && holesScored === 18) {
                            matchComplete = true;
                            if (team0Score < team1Score) {
                                matchResult = 0;
                                team0Points = 1;
                            } else if (team1Score < team0Score) {
                                matchResult = 1;
                                team1Points = 1;
                            } else {
                                matchResult = 0.5;
                                team0Points = 0.5;
                                team1Points = 0.5;
                            }
                        }
                    } else if (hasLiveScores && event.scoringType === 'match') {
                        const matchPlayResult = calculateMatchPlayResult(liveData);
                        matchResult = matchPlayResult.result;
                        match.result = matchResult;
                        match.holeFinished = matchPlayResult.holeFinished;
                        match.marginOfVictory = matchPlayResult.margin;
                        
                        // Check if all 18 holes are played (not just if there's a winner)
                        let holesScored = 0;
                        if (liveData.scores && Object.keys(liveData.scores).length > 0) {
                            holesScored = Object.values(liveData.scores[Object.keys(liveData.scores)[0]] || {}).filter(s => s !== null).length;
                        }
                        
                        if (matchResult !== null && holesScored === 18) {
                            matchComplete = true;
                            if (matchResult === 0) {
                                team0Points = 1;
                                if (event.blowoutBonus) {
                                    calculateBlowoutBonus(roundIndex, matchIndex);
                                    team0Points += match.blowoutBonus;
                                }
                            } else if (matchResult === 1) {
                                team1Points = 1;
                                if (event.blowoutBonus) {
                                    calculateBlowoutBonus(roundIndex, matchIndex);
                                    team1Points += match.blowoutBonus;
                                }
                            } else if (matchResult === 0.5) {
                                team0Points = 0.5;
                                team1Points = 0.5;
                            }
                        }
                    } else if (matchResult !== null) {
                        // Manual result entry
                        matchComplete = true;
                        if (matchResult === 0) {
                            team0Points = 1;
                            if (event.blowoutBonus && event.scoringType === 'match') {
                                team0Points += (match.blowoutBonus || 0);
                            }
                        } else if (matchResult === 1) {
                            team1Points = 1;
                            if (event.blowoutBonus && event.scoringType === 'match') {
                                team1Points += (match.blowoutBonus || 0);
                            }
                        } else if (matchResult === 0.5) {
                            team0Points = 0.5;
                            team1Points = 0.5;
                        }
                    }
                    
                    const team0Winner = matchComplete && matchResult === 0;
                    const team1Winner = matchComplete && matchResult === 1;
                    const isTie = matchComplete && matchResult === 0.5;
                    
                    html += `
                        <div style="border-bottom: 1px solid #e0e0e0; padding: 15px; display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center; ${matchComplete ? 'background: #f8f9fa;' : ''}">
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-radius: 6px; ${team0Winner ? 'background: #d4edda; border: 2px solid #28a745;' : isTie ? 'background: #fff3cd; border: 2px solid #ffc107;' : 'background: white; border: 2px solid #e0e0e0;'}">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 3px;">${match.team0Players.join(' & ')}</div>
                                    <div style="font-size: 0.85em; color: #7f8c8d;">${event.teams[0].name}</div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="font-size: 1.5em; font-weight: 700; color: ${team0Winner ? '#28a745' : '#2c3e50'}; min-width: 40px; text-align: center;">
                                        ${team0Score !== null ? team0Score : '-'}
                                    </div>
                                    ${matchComplete && team0Points > 0 ? `
                                        <div style="background: #28a745; color: white; padding: 4px 12px; border-radius: 20px; font-weight: 600; font-size: 0.9em;">
                                            +${team0Points.toFixed(team0Points % 1 === 0 ? 0 : 2)} pts
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            
                            <div style="font-weight: 600; color: #95a5a6; font-size: 1.1em;">VS</div>
                            
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-radius: 6px; ${team1Winner ? 'background: #d4edda; border: 2px solid #28a745;' : isTie ? 'background: #fff3cd; border: 2px solid #ffc107;' : 'background: white; border: 2px solid #e0e0e0;'}">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #2c3e50; margin-bottom: 3px;">${match.team1Players.join(' & ')}</div>
                                    <div style="font-size: 0.85em; color: #7f8c8d;">${event.teams[1].name}</div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="font-size: 1.5em; font-weight: 700; color: ${team1Winner ? '#28a745' : '#2c3e50'}; min-width: 40px; text-align: center;">
                                        ${team1Score !== null ? team1Score : '-'}
                                    </div>
                                    ${matchComplete && team1Points > 0 ? `
                                        <div style="background: #28a745; color: white; padding: 4px 12px; border-radius: 20px; font-weight: 600; font-size: 0.9em;">
                                            +${team1Points.toFixed(team1Points % 1 === 0 ? 0 : 2)} pts
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function updateMatchResult(roundIndex, matchIndex, teamIndex, result) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            
            if (result === 'win') {
                match.result = teamIndex;
            } else if (result === 'tie') {
                match.result = 0.5;
            } else if (result === 'loss') {
                match.result = teamIndex === 0 ? 1 : 0;
            } else {
                match.result = null;
            }

            calculateBlowoutBonus(roundIndex, matchIndex);
            calculatePoints();
            renderScoring();
            renderStandings();
        }

        function updateStrokeScore(roundIndex, matchIndex, teamIndex, score) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            
            if (teamIndex === 0) {
                match.team0Score = score ? parseInt(score) : null;
            } else {
                match.team1Score = score ? parseInt(score) : null;
            }

            // Determine winner in stroke play
            if (match.team0Score !== null && match.team1Score !== null) {
                if (match.team0Score < match.team1Score) {
                    match.result = 0; // Team 0 wins (lower score)
                } else if (match.team1Score < match.team0Score) {
                    match.result = 1; // Team 1 wins (lower score)
                } else {
                    match.result = 0.5; // Tie
                }
            } else {
                match.result = null;
            }

            calculatePoints();
            renderScoring();
            renderStandings();
        }

        function updateMargin(roundIndex, matchIndex, margin) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            match.marginOfVictory = margin ? parseInt(margin) : null;
            calculateBlowoutBonus(roundIndex, matchIndex);
            calculatePoints();
            renderScoring();
            renderStandings();
        }

        function updateHoleFinished(roundIndex, matchIndex, hole) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            match.holeFinished = hole ? parseInt(hole) : null;
            calculateBlowoutBonus(roundIndex, matchIndex);
            calculatePoints();
            renderScoring();
            renderStandings();
        }

        function calculateBlowoutBonus(roundIndex, matchIndex) {
            const match = event.rounds[roundIndex].matches[matchIndex];
            
            // Check if blowout bonus applies:
            // - Event has bonus enabled
            // - Match was won (not tied)
            // - Finished before hole 17
            // - Has scores to calculate stroke difference
            if (event.blowoutBonus && 
                match.result !== null && 
                match.result !== 0.5 && 
                match.holeFinished && 
                match.holeFinished < 17) {
                
                // Get the actual stroke difference from live scores
                const liveData = getLiveMatchData(roundIndex, matchIndex);
                
                if (liveData.hasScores && liveData.team0Total !== null && liveData.team1Total !== null) {
                    const strokeDifference = Math.abs(liveData.team0Total - liveData.team1Total);
                    match.marginOfVictory = strokeDifference;
                    match.blowoutBonus = strokeDifference * 0.05;
                } else {
                    // Fallback to manual entry if available
                    if (match.marginOfVictory) {
                        match.blowoutBonus = match.marginOfVictory * 0.05;
                    } else {
                        match.blowoutBonus = 0;
                    }
                }
            } else {
                match.blowoutBonus = 0;
            }
        }

        function calculatePoints() {
            // Safety check: ensure teams exist before calculating
            if (!event.teams || event.teams.length < 2) {
                console.log('calculatePoints: No teams found');
                return;
            }
            
            console.log('=== calculatePoints START ===');
            console.log('Scoring type:', event.scoringType);
            console.log('Teams before:', {team0: event.teams[0].points, team1: event.teams[1].points});
            
            event.teams[0].points = 0;
            event.teams[1].points = 0;

            event.rounds.forEach((round, roundIndex) => {
                console.log(`Round ${roundIndex + 1}: ${round.matches.length} matches`);
                
                round.matches.forEach((match, matchIndex) => {
                    // Update match data from live scores if available
                    const liveData = getLiveMatchData(roundIndex, matchIndex);
                    
                    console.log(`  Match ${matchIndex + 1}:`, {
                        hasScores: liveData.hasScores,
                        result: match.result,
                        team0Score: match.team0Score,
                        team1Score: match.team1Score
                    });
                    
                    if (liveData.hasScores) {
                        if (event.scoringType === 'stroke') {
                            match.team0Score = liveData.team0Total;
                            match.team1Score = liveData.team1Total;
                            
                            // Only set result if all 18 holes are played
                            let holesScored = 0;
                            if (liveData.scores && Object.keys(liveData.scores).length > 0) {
                                holesScored = Object.values(liveData.scores[Object.keys(liveData.scores)[0]] || {}).filter(s => s !== null).length;
                            }
                            
                            if (match.team0Score !== null && match.team1Score !== null && holesScored === 18) {
                                if (match.team0Score < match.team1Score) {
                                    match.result = 0;
                                } else if (match.team1Score < match.team0Score) {
                                    match.result = 1;
                                } else {
                                    match.result = 0.5;
                                }
                            }
                        } else if (event.scoringType === 'match') {
                            const matchPlayResult = calculateMatchPlayResult(liveData);
                            match.holeFinished = matchPlayResult.holeFinished;
                            // Always store the live result for display purposes (scoreboard/standings)
                            match.result = matchPlayResult.result;
                            // Track whether the match is truly complete for points awarding
                            match.isComplete = matchPlayResult.isComplete;
                            
                            // For match play, margin is holes won, but we need stroke difference for bonus
                            // Calculate actual stroke difference from totals
                            if (liveData.team0Total !== null && liveData.team1Total !== null) {
                                const strokeDiff = Math.abs(liveData.team0Total - liveData.team1Total);
                                match.marginOfVictory = strokeDiff;
                            }
                            
                            // Calculate blowout bonus based on stroke difference
                            if (event.blowoutBonus && 
                                match.isComplete &&
                                match.result !== null && 
                                match.result !== 0.5 && 
                                match.holeFinished && 
                                match.holeFinished < 17 && 
                                match.marginOfVictory) {
                                match.blowoutBonus = match.marginOfVictory * 0.05;
                            } else {
                                match.blowoutBonus = 0;
                            }
                        }
                    }
                    
                    // Award points only when the match is genuinely over.
                    // For live match play: use isComplete flag (set only when closed out or 18 holes done).
                    // For stroke play: result is only set when all 18 holes are scored (already correct above).
                    // For manually-entered results: treat match.result !== null as complete (no live scores).
                    let matchComplete = false;
                    if (liveData.hasScores && event.scoringType === 'match') {
                        // Live match play ‚Äî use the explicit isComplete flag
                        matchComplete = !!match.isComplete;
                    } else if (match.result !== null) {
                        // Stroke play (guarded by holesScored===18 above) or manual entry
                        matchComplete = true;
                    }
                    
                    if (matchComplete) {
                        console.log(`    Match ${matchIndex + 1} COMPLETE - awarding points:`, match.result);
                        
                        if (match.result === 0) {
                            event.teams[0].points += 1;
                            event.teams[0].points += (match.blowoutBonus || 0);
                            console.log(`      Team 0 gets 1 + ${match.blowoutBonus || 0} = ${1 + (match.blowoutBonus || 0)}`);
                        } else if (match.result === 1) {
                            event.teams[1].points += 1;
                            event.teams[1].points += (match.blowoutBonus || 0);
                            console.log(`      Team 1 gets 1 + ${match.blowoutBonus || 0} = ${1 + (match.blowoutBonus || 0)}`);
                        } else if (match.result === 0.5) {
                            event.teams[0].points += 0.5;
                            event.teams[1].points += 0.5;
                            console.log(`      Both teams get 0.5`);
                        }
                    } else {
                        console.log(`    Match ${matchIndex + 1} NOT complete`);
                    }
                });
            });
            
            console.log('Teams after:', {team0: event.teams[0].points, team1: event.teams[1].points});
            console.log('=== calculatePoints END ===');
        }

        function renderStandings() {
            const container = document.getElementById('standingsContent');
            
            const hasScores = event.rounds.some(round => 
                round.matches.some(match => match.result !== null)
            );

            if (!hasScores) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üèÜ</div>
                        <h3>No Scores Yet</h3>
                        <p>Start entering match results to see standings</p>
                    </div>
                `;
                return;
            }

            const team0Leading = event.teams[0].points > event.teams[1].points;
            const team1Leading = event.teams[1].points > event.teams[0].points;

            let html = `
                <h2 style="margin-bottom: 30px;">${event.name} - Standings</h2>
                <div class="score-summary">
                    <div class="team-score team-0 ${team0Leading ? 'leading' : ''}">
                        <h3>${event.teams[0].name}</h3>
                        <div class="score">${event.teams[0].points}</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">Captain: ${event.teams[0].captain}</div>
                    </div>
                    <div class="score-divider">-</div>
                    <div class="team-score team-1 ${team1Leading ? 'leading' : ''}">
                        <h3>${event.teams[1].name}</h3>
                        <div class="score">${event.teams[1].points}</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">Captain: ${event.teams[1].captain}</div>
                    </div>
                </div>
            `;

            // Day by day breakdown
            event.rounds.forEach((round, roundIndex) => {
                let roundTeam0Points = 0;
                let roundTeam1Points = 0;

                round.matches.forEach((match, matchIndex) => {
                    // Check if match is complete (same logic as calculatePoints)
                    const liveData = getLiveMatchData(roundIndex, matchIndex);
                    let matchComplete = false;
                    
                    // If result is set, match is complete (either from live scoring or manual entry)
                    if (match.result !== null) {
                        matchComplete = true;
                    }
                    
                    // Only count points for completed matches
                    if (matchComplete) {
                        if (match.result === 0) {
                            roundTeam0Points += 1;
                            roundTeam0Points += (match.blowoutBonus || 0);
                        }
                        else if (match.result === 1) {
                            roundTeam1Points += 1;
                            roundTeam1Points += (match.blowoutBonus || 0);
                        }
                        else if (match.result === 0.5) {
                            roundTeam0Points += 0.5;
                            roundTeam1Points += 0.5;
                        }
                    }
                });

                html += `
                    <div class="round-card">
                        <div class="round-header">
                            <h3>Round ${round.roundNumber}: ${round.format}${round.date ? ` - ${new Date(round.date + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}` : ''}</h3>
                            <div style="font-size: 1.2em; font-weight: 600;">
                                ${event.teams[0].name}: ${roundTeam0Points} - ${event.teams[1].name}: ${roundTeam1Points}
                            </div>
                        </div>
                        <div style="display: grid; gap: 10px;">
                `;

                round.matches.forEach((match, matchIndex) => {
                    let resultBadge = '';
                    const isStrokePlay = event.scoringType === 'stroke';
                    
                    if (match.result === 0) {
                        resultBadge = `<span class="result-badge win">${event.teams[0].name} Wins</span>`;
                        if (isStrokePlay && match.team0Score !== null && match.team1Score !== null) {
                            resultBadge += ` <span style="color: #7f8c8d; margin-left: 8px;">${match.team0Score} vs ${match.team1Score}</span>`;
                        }
                        if (match.blowoutBonus > 0) {
                            resultBadge += ` <span class="result-badge" style="background: #f39c12;">‚≠ê +${match.blowoutBonus.toFixed(2)} Bonus</span>`;
                        }
                    } else if (match.result === 1) {
                        resultBadge = `<span class="result-badge win">${event.teams[1].name} Wins</span>`;
                        if (isStrokePlay && match.team0Score !== null && match.team1Score !== null) {
                            resultBadge += ` <span style="color: #7f8c8d; margin-left: 8px;">${match.team0Score} vs ${match.team1Score}</span>`;
                        }
                        if (match.blowoutBonus > 0) {
                            resultBadge += ` <span class="result-badge" style="background: #f39c12;">‚≠ê +${match.blowoutBonus.toFixed(2)} Bonus</span>`;
                        }
                    } else if (match.result === 0.5) {
                        resultBadge = `<span class="result-badge tie">Tie</span>`;
                        if (isStrokePlay && match.team0Score !== null && match.team1Score !== null) {
                            resultBadge += ` <span style="color: #7f8c8d; margin-left: 8px;">${match.team0Score} vs ${match.team1Score}</span>`;
                        }
                    }

                    let matchDetails = '';
                    if (!isStrokePlay && match.holeFinished && match.marginOfVictory) {
                        matchDetails = `<span style="color: #95a5a6; font-size: 0.9em; margin-left: 10px;">(Finished hole ${match.holeFinished}, ${match.marginOfVictory} stroke difference)</span>`;
                    } else if (!isStrokePlay && match.holeFinished) {
                        matchDetails = `<span style="color: #95a5a6; font-size: 0.9em; margin-left: 10px;">(Finished hole ${match.holeFinished})</span>`;
                    }

                    html += `
                        <div style="background: white; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${match.team0Players.join(' & ')}</strong> 
                                <span style="color: #7f8c8d;">vs</span> 
                                <strong>${match.team1Players.join(' & ')}</strong>
                                ${matchDetails}
                            </div>
                            <div style="text-align: right;">
                                ${resultBadge}
                            </div>
                        </div>
                    `;
                });

                html += `</div></div>`;
            });

            container.innerHTML = html;
        }

        // Saved Events Management
        async function loadEventsFromSupabase() {
            if (!supabaseClient || !isSupabaseEnabled) {
                return [];
            }
            
            try {
                // Try both column names
                let result = await supabaseClient
                    .from('events')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (result.error && result.error.code === '42703') {
                    // Try without ordering if column doesn't exist
                    result = await supabaseClient
                        .from('events')
                        .select('*');
                }
                
                if (result.error) {
                    console.error('Supabase load error:', result.error);
                    return [];
                }
                
                // Convert Supabase events to our format
                const events = result.data || [];
                return events.map(e => ({
                    id: e.event_id || e.id,
                    name: e.event_name,
                    scoringType: e.scoring_type,
                    blowoutBonus: e.blowout_bonus_enabled,
                    // We'll need to load full event data when selected
                    // For now just show basic info in the list
                    savedDate: e.created_at || e.updated_at
                }));
            } catch (error) {
                console.error('Supabase load error:', error);
                return [];
            }
        }
        
        function getSavedEvents() {
            const saved = localStorage.getItem('golfEvents');
            return saved ? JSON.parse(saved) : [];
        }
        
        async function getAllSavedEvents() {
            // If Supabase is enabled, use it as the source of truth
            if (isSupabaseEnabled && supabaseClient) {
                console.log('Loading events from Supabase (source of truth)');
                const supabaseEvents = await loadEventsFromSupabase();
                
                if (supabaseEvents.length > 0) {
                    console.log(`Found ${supabaseEvents.length} events in Supabase`);
                    return supabaseEvents;
                } else {
                    console.log('No events in Supabase, showing localStorage events');
                    // Fallback to localStorage if Supabase is empty
                    return getSavedEvents();
                }
            }
            
            // Supabase not enabled, use localStorage
            console.log('Loading events from localStorage');
            return getSavedEvents();
        }

        async function saveCurrentEvent() {
            if (!event.name) return;
            
            const savedEvents = getSavedEvents();
            const eventToSave = {
                ...event,
                teamRosters: teamRosters,
                savedDate: new Date().toISOString(),
                id: event.id || `local_${Date.now()}`
            };
            
            event.id = eventToSave.id;
            
            // Save to localStorage (fast, always works)
            const existingIndex = savedEvents.findIndex(e => e.id === event.id);
            if (existingIndex >= 0) {
                savedEvents[existingIndex] = eventToSave;
            } else {
                savedEvents.push(eventToSave);
            }
            
            localStorage.setItem('golfEvents', JSON.stringify(savedEvents));
            refreshEventsList();
            
            // Also save to Supabase if enabled
            if (isSupabaseEnabled) {
                await saveEventToSupabase(eventToSave);
            }
        }
        
        async function saveEventToSupabase(eventData) {
            // Double-check Supabase is actually configured
            if (!supabaseClient || !isSupabaseEnabled) {
                console.log('Supabase not configured, skipping sync');
                return;
            }
            
            try {
                showSyncStatus('Syncing...', 'blue');
                
                // Step 1: Save or update event
                const eventId = typeof eventData.id === 'string' && eventData.id.startsWith('local_') ? null : eventData.id;
                
                // Build event object
                // Note: For best results, add a UNIQUE constraint on event_name in Supabase:
                // ALTER TABLE events ADD CONSTRAINT events_event_name_unique UNIQUE (event_name);
                // Store full event JSON blob on the events row so rosters,
                // rounds, liveScores etc. survive without needing related tables.
                const eventBlob = JSON.stringify({
                    teams: eventData.teams || [],
                    rounds: eventData.rounds || [],
                    liveScores: eventData.liveScores || {},
                    teamRosters: eventData.teamRosters || []
                });
                
                const eventPayload = {
                    event_name: eventData.name,
                    scoring_type: eventData.scoringType,
                    blowout_bonus_enabled: eventData.blowoutBonus,
                    num_rounds: eventData.rounds ? eventData.rounds.length : 0,
                    event_data: eventBlob
                };
                
                let savedEvent, eventError;
                
                if (eventId !== null) {
                    // Update existing event - try event_id first, then id
                    let result = await supabaseClient
                        .from('events')
                        .update(eventPayload)
                        .eq('event_id', eventId)
                        .select()
                        .single();
                    
                    // If column doesn't exist (42703), try 'id' instead
                    if (result.error && result.error.code === '42703') {
                        result = await supabaseClient
                            .from('events')
                            .update(eventPayload)
                            .eq('id', eventId)
                            .select()
                            .single();
                    }
                    
                    savedEvent = result.data;
                    eventError = result.error;
                } else {
                    // Insert new event - first check if name already exists
                    const { data: existingEvents } = await supabaseClient
                        .from('events')
                        .select('id, event_id, event_name')
                        .eq('event_name', eventPayload.event_name);
                    
                    if (existingEvents && existingEvents.length > 0) {
                        // Event with this name already exists - update it instead
                        const existingEventId = existingEvents[0].event_id || existingEvents[0].id;
                        console.log(`Event "${eventPayload.event_name}" already exists, updating instead (ID: ${existingEventId})`);
                        
                        let result = await supabaseClient
                            .from('events')
                            .update(eventPayload)
                            .eq('event_id', existingEventId)
                            .select()
                            .single();
                        
                        if (result.error && result.error.code === '42703') {
                            result = await supabaseClient
                                .from('events')
                                .update(eventPayload)
                                .eq('id', existingEventId)
                                .select()
                                .single();
                        }
                        
                        savedEvent = result.data;
                        eventError = result.error;
                        
                        // Update local ID to match Supabase
                        if (!eventError && savedEvent) {
                            const dbEventId = savedEvent.event_id || savedEvent.id;
                            event.id = dbEventId;
                            eventData.id = dbEventId;
                        }
                    } else {
                        // Insert new event
                        const result = await supabaseClient
                            .from('events')
                            .insert(eventPayload)
                            .select()
                            .single();
                        savedEvent = result.data;
                        eventError = result.error;
                    }
                }
                
                if (eventError) throw eventError;
                
                if (!savedEvent) {
                    throw new Error('Event save returned null - check database permissions and schema');
                }
                
                // Try both column names for compatibility (id vs event_id)
                const dbEventId = savedEvent.event_id || savedEvent.id;
                
                if (!dbEventId) {
                    console.error('Event saved but no ID found:', savedEvent);
                    throw new Error('Event was saved but no ID was returned (tried event_id and id)');
                }
                
                console.log('Event saved with ID:', dbEventId);
                
                // Update local ID if it was generated by Supabase
                if (eventData.id !== dbEventId) {
                    event.id = dbEventId;
                    eventData.id = dbEventId;
                }
                
                // Step 2: Save teams
                if (eventData.teams && eventData.teams.length > 0) {
                    for (const team of eventData.teams) {
                        const teamId = team.id && !team.id.toString().startsWith('local_') ? team.id : null;
                        
                        const teamPayload = {
                            event_id: dbEventId,
                            team_name: team.name,
                            total_points: team.points || 0
                        };
                        
                        let savedTeam, teamError;
                        
                        if (teamId !== null) {
                            // Update existing team - try team_id first, then id
                            let result = await supabaseClient
                                .from('teams')
                                .update(teamPayload)
                                .eq('team_id', teamId)
                                .select()
                                .single();
                            
                            if (result.error && result.error.code === '42703') {
                                result = await supabaseClient
                                    .from('teams')
                                    .update(teamPayload)
                                    .eq('id', teamId)
                                    .select()
                                    .single();
                            }
                            
                            savedTeam = result.data;
                            teamError = result.error;
                        } else {
                            // Insert new team
                            const result = await supabaseClient
                                .from('teams')
                                .insert(teamPayload)
                                .select()
                                .single();
                            savedTeam = result.data;
                            teamError = result.error;
                        }
                        
                        if (teamError) {
                            console.error('Team save error:', teamError);
                            throw teamError;
                        }
                        
                        if (!savedTeam) {
                            throw new Error('Team save returned null');
                        }
                        
                        const dbTeamId = savedTeam.team_id || savedTeam.id;
                        if (team.id !== dbTeamId) {
                            team.id = dbTeamId;
                        }
                        
                        // Player roster is stored in the event_data blob on the events row.
                        // Skipping players/team_players writes ‚Äî blocked by RLS policy.
                    }
                }
                
                // Step 3: Save rounds and matches
                if (eventData.rounds && eventData.rounds.length > 0) {
                    console.log('Saving rounds for event ID:', dbEventId);
                    
                    for (const round of eventData.rounds) {
                        const roundId = round.id && !round.id.toString().startsWith('local_') ? round.id : null;
                        
                        const roundPayload = {
                            event_id: dbEventId,
                            round_number: round.roundNumber,
                            format: round.format,
                            round_date: round.date || null
                        };
                        
                        console.log('Round payload:', roundPayload);
                        
                        let savedRound, roundError;
                        
                        if (roundId !== null) {
                            // Update existing round - try round_id first, then id
                            let result = await supabaseClient
                                .from('rounds')
                                .update(roundPayload)
                                .eq('round_id', roundId)
                                .select()
                                .single();
                            
                            if (result.error && result.error.code === '42703') {
                                result = await supabaseClient
                                    .from('rounds')
                                    .update(roundPayload)
                                    .eq('id', roundId)
                                    .select()
                                    .single();
                            }
                            
                            savedRound = result.data;
                            roundError = result.error;
                        } else {
                            // Insert new round
                            const result = await supabaseClient
                                .from('rounds')
                                .insert(roundPayload)
                                .select()
                                .single();
                            savedRound = result.data;
                            roundError = result.error;
                        }
                        
                        if (roundError) {
                            console.error('Round save error:', roundError);
                            throw roundError; // Stop if round save fails
                        }
                        
                        if (!savedRound) {
                            throw new Error('Round save returned null');
                        }
                        
                        const dbRoundId = savedRound.round_id || savedRound.id;
                        if (round.id !== dbRoundId) {
                            round.id = dbRoundId;
                        }
                        
                        // Save matches for this round
                        if (round.matches && round.matches.length > 0) {
                            for (const match of round.matches) {
                                // Determine match result
                                let matchResult = 'pending';
                                if (match.result === 0) matchResult = 'team_0_win';
                                else if (match.result === 1) matchResult = 'team_1_win';
                                else if (match.result === 0.5) matchResult = 'tie';
                                
                                const matchId = match.id && !match.id.toString().startsWith('local_') ? match.id : null;
                                
                                // Build match payload - only include fields with valid values
                                const matchPayload = {
                                    round_id: dbRoundId,
                                    team_0_id: eventData.teams[0].id,
                                    team_1_id: eventData.teams[1].id,
                                    match_result: matchResult,
                                    blowout_bonus: match.blowoutBonus || 0
                                };
                                
                                // Only add team scores if they exist
                                if (match.team0Score !== null && match.team0Score !== undefined) {
                                    matchPayload.team_0_score = match.team0Score;
                                }
                                if (match.team1Score !== null && match.team1Score !== undefined) {
                                    matchPayload.team_1_score = match.team1Score;
                                }
                                
                                // Only add hole_finished if it's a valid number (1-18)
                                if (match.holeFinished && match.holeFinished >= 1 && match.holeFinished <= 18) {
                                    matchPayload.hole_finished = match.holeFinished;
                                }
                                
                                // Only add margin_of_victory if it exists
                                if (match.marginOfVictory !== null && match.marginOfVictory !== undefined) {
                                    matchPayload.margin_of_victory = match.marginOfVictory;
                                }
                                
                                let savedMatch, matchError;
                                
                                if (matchId !== null) {
                                    // Update existing match - try match_id first, then id
                                    let result = await supabaseClient
                                        .from('matches')
                                        .update(matchPayload)
                                        .eq('match_id', matchId)
                                        .select()
                                        .single();
                                    
                                    if (result.error && result.error.code === '42703') {
                                        result = await supabaseClient
                                            .from('matches')
                                            .update(matchPayload)
                                            .eq('id', matchId)
                                            .select()
                                            .single();
                                    }
                                    
                                    savedMatch = result.data;
                                    matchError = result.error;
                                } else {
                                    // Insert new match
                                    const result = await supabaseClient
                                        .from('matches')
                                        .insert(matchPayload)
                                        .select()
                                        .single();
                                    savedMatch = result.data;
                                    matchError = result.error;
                                }
                                
                                if (matchError) {
                                    console.error('Match save error:', matchError);
                                    throw matchError;
                                }
                                
                                if (!savedMatch) {
                                    throw new Error('Match save returned null');
                                }
                                
                                const dbMatchId = savedMatch.match_id || savedMatch.id;
                                if (match.id !== dbMatchId) {
                                    match.id = dbMatchId;
                                }
                            }
                        }
                    }
                }
                
                // Step 4: Save live scores (hole by hole)
                if (eventData.liveScores) {
                    console.log('Saving hole scores...');
                    
                    for (let roundIndex = 0; roundIndex < eventData.rounds.length; roundIndex++) {
                        const round = eventData.rounds[roundIndex];
                        if (!eventData.liveScores[roundIndex]) continue;
                        
                        for (let matchIndex = 0; matchIndex < round.matches.length; matchIndex++) {
                            const match = round.matches[matchIndex];
                            if (!match.id) {
                                console.warn(`Match ${matchIndex} has no ID, skipping hole scores`);
                                continue;
                            }
                            
                            if (!eventData.liveScores[roundIndex][matchIndex]) continue;
                            
                            const matchScores = eventData.liveScores[roundIndex][matchIndex];
                            
                            for (const playerName in matchScores) {
                                try {
                                    // Get player ID - select all columns to avoid column name issues
                                    let playerResult = await supabaseClient
                                        .from('players')
                                        .select('*')
                                        .eq('player_name', playerName)
                                        .single();
                                    
                                    // If player doesn't exist, create them first
                                    if (playerResult.error) {
                                        console.log(`Creating player: ${playerName}`);
                                        const insertResult = await supabaseClient
                                            .from('players')
                                            .insert({ player_name: playerName })
                                            .select('*')
                                            .single();
                                        
                                        if (insertResult.error) {
                                            console.error(`Failed to create player ${playerName}:`, insertResult.error);
                                            continue;
                                        }
                                        playerResult = insertResult;
                                    }
                                    
                                    const player = playerResult.data;
                                    if (!player) continue;
                                    
                                    // Try common column names for player ID
                                    const playerId = player.player_id || player.id || player.playerId;
                                    
                                    // Save each hole score
                                    const scores = matchScores[playerName];
                                    for (let holeIndex = 0; holeIndex < scores.length; holeIndex++) {
                                        if (scores[holeIndex] !== null) {
                                            const holeScorePayload = {
                                                match_id: match.id,
                                                player_id: playerId,
                                                hole_number: holeIndex + 1,
                                                score: scores[holeIndex]
                                            };
                                            
                                            // Use upsert to update if exists
                                            const holeResult = await supabaseClient
                                                .from('hole_scores')
                                                .upsert(holeScorePayload, {
                                                    onConflict: 'match_id,player_id,hole_number'
                                                });
                                            
                                            if (holeResult.error) {
                                                console.error(`Failed to save hole score for ${playerName} hole ${holeIndex + 1}:`, holeResult.error);
                                            }
                                        }
                                    }
                                    
                                    console.log(`Saved hole scores for ${playerName}`);
                                } catch (error) {
                                    console.error(`Error saving scores for ${playerName}:`, error);
                                }
                            }
                        }
                    }
                    
                    console.log('Hole scores saved');
                }
                
                showSyncStatus('Synced ‚úì', 'green');
                setTimeout(() => hideSyncStatus(), 2000);
                
            } catch (error) {
                console.error('Supabase sync error:', error);
                
                // Check if it's a configuration issue
                if (error.message && error.message.includes('Failed to fetch')) {
                    console.log('üí° Tip: Make sure Supabase is properly configured with valid URL and API key');
                    // Disable Supabase to prevent repeated errors
                    isSupabaseEnabled = false;
                    updateSupabaseStatusIndicator();
                    console.log('‚ö†Ô∏è Supabase sync disabled due to connection error - using localStorage only');
                }
                
                showSyncStatus('Sync failed', 'red');
                setTimeout(() => hideSyncStatus(), 3000);
            }
        }
        
        function showSyncStatus(message, color) {
            let statusEl = document.getElementById('syncStatus');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'syncStatus';
                statusEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 10px 20px;
                    border-radius: 20px;
                    color: white;
                    font-weight: 600;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    transition: opacity 0.3s;
                `;
                document.body.appendChild(statusEl);
            }
            
            const colors = {
                'blue': '#3498db',
                'green': '#2ecc71',
                'red': '#e74c3c'
            };
            
            statusEl.style.backgroundColor = colors[color] || colors.blue;
            statusEl.textContent = message;
            statusEl.style.opacity = '1';
        }
        
        function hideSyncStatus() {
            const statusEl = document.getElementById('syncStatus');
            if (statusEl) {
                statusEl.style.opacity = '0';
            }
        }

        async function loadSavedEvent(eventId) {
            let savedEvent = null;
            
            // Always search localStorage first by ID ‚Äî it has the full event data
            // including teamRosters, rounds, liveScores, etc.
            const localEvents = getSavedEvents();
            savedEvent = localEvents.find(e => e.id === eventId);
            
            // If not found by ID (e.g. Supabase ID differs from local ID),
            // try matching by event name using the Supabase stub's name
            if (!savedEvent && supabaseClient && isSupabaseEnabled) {
                try {
                    showSyncStatus('Loading from cloud...', 'blue');
                    
                    let result = await supabaseClient
                        .from('events')
                        .select('*')
                        .eq('event_id', eventId)
                        .single();
                    
                    if (result.error && result.error.code === '42703') {
                        result = await supabaseClient
                            .from('events')
                            .select('*')
                            .eq('id', eventId)
                            .single();
                    }
                    
                    if (result.data) {
                        const eventName = result.data.event_name;
                        // Try to find the full event in localStorage by name first
                        savedEvent = localEvents.find(e => 
                            e.name && e.name.toLowerCase() === eventName.toLowerCase()
                        );
                        
                        if (!savedEvent) {
                            // No local copy ‚Äî try to restore from the event_data blob
                            let blob = {};
                            if (result.data.event_data) {
                                try { blob = JSON.parse(result.data.event_data); } catch(e) {}
                            }
                            savedEvent = {
                                id: result.data.event_id || result.data.id,
                                name: eventName,
                                scoringType: result.data.scoring_type,
                                blowoutBonus: result.data.blowout_bonus_enabled,
                                teams: blob.teams || [],
                                rounds: blob.rounds || [],
                                liveScores: blob.liveScores || {},
                                teamRosters: blob.teamRosters || []
                            };
                        }
                    }
                    
                    hideSyncStatus();
                } catch (error) {
                    console.error('Error loading from Supabase:', error);
                    hideSyncStatus();
                }
            }
            
            if (!savedEvent) {
                alert('Event not found');
                return;
            }
            
            // CLEAR ALL STALE DATA FIRST
            clearAllData();
            
            // Load the event
            event = { ...savedEvent };
            
            // Backward compatibility: convert 'days' to 'rounds' if needed
            if (event.days && !event.rounds) {
                event.rounds = event.days;
                delete event.days;
            }
            
            if (savedEvent.teamRosters) {
                teamRosters = JSON.parse(JSON.stringify(savedEvent.teamRosters));
                // Ensure players are objects {name, phone}, not plain strings
                teamRosters.forEach(roster => {
                    roster.players = roster.players.map(p =>
                        typeof p === 'string' ? { name: p, phone: null } : p
                    );
                });
            } else if (savedEvent.teams && savedEvent.teams.length >= 2) {
                // No teamRosters saved ‚Äî reconstruct from event.teams
                teamRosters = savedEvent.teams.map(team => ({
                    name: team.name,
                    captain: team.players ? team.players.indexOf(team.captain) : null,
                    players: (team.players || []).map(p =>
                        typeof p === 'string' ? { name: p, phone: null } : p
                    )
                }));
            }
            
            // Populate form fields
            document.getElementById('eventName').value = event.name;
            document.getElementById('team0Name').value = teamRosters[0].name || 'Team USA';
            document.getElementById('team1Name').value = teamRosters[1].name || 'Team Europe';
            document.getElementById('numRounds').value = event.rounds.length;
            document.getElementById('scoringType').value = event.scoringType || 'match';
            document.getElementById('blowoutBonus').checked = event.blowoutBonus || false;
            
            updateRoundFormats();
            
            // Set day formats, dates, and course selections
            setTimeout(() => {
                event.rounds.forEach((round, i) => {
                    const formatEl = document.getElementById(`format${i + 1}`);
                    const dateEl = document.getElementById(`date${i + 1}`);
                    if (formatEl) formatEl.value = round.format;
                    if (dateEl && round.date) dateEl.value = round.date;
                    if (round.course) renderSelectedCourse(i + 1, round.course);
                });
            }, 100);
            
            // Render everything
            renderBothRosters();
            renderMatchups();
            renderScoring();
            renderLiveScoring();
            renderLiveScoreboardTab();
            renderStandings();
            
            alert(`Event "${event.name}" loaded successfully!`);
            switchTab('teams');
        }

        async function deleteSavedEvent(eventId) {
            if (!confirm('Are you sure you want to delete this event?')) return;
            
            // Delete from Supabase if enabled
            if (supabaseClient && isSupabaseEnabled) {
                try {
                    // Try both column names for compatibility
                    let deleteError;
                    
                    // Try event_id first
                    const result1 = await supabaseClient
                        .from('events')
                        .delete()
                        .eq('event_id', eventId);
                    
                    if (result1.error && result1.error.code === '42703') {
                        // Column doesn't exist, try 'id'
                        const result2 = await supabaseClient
                            .from('events')
                            .delete()
                            .eq('id', eventId);
                        deleteError = result2.error;
                    } else {
                        deleteError = result1.error;
                    }
                    
                    if (deleteError) {
                        console.error('Supabase delete error:', deleteError);
                        alert('Failed to delete from Supabase: ' + deleteError.message);
                    } else {
                        console.log('Event deleted from Supabase:', eventId);
                    }
                } catch (error) {
                    console.error('Supabase delete error:', error);
                }
            }
            
            // Delete from localStorage
            const savedEvents = getSavedEvents();
            const filtered = savedEvents.filter(e => e.id !== eventId);
            localStorage.setItem('golfEvents', JSON.stringify(filtered));
            refreshEventsList();
        }

        async function refreshEventsList() {
            const savedEvents = await getAllSavedEvents();
            const container = document.getElementById('savedEventsList');
            const statusEl = document.getElementById('eventListStatus');
            
            // Show where events are loaded from
            if (isSupabaseEnabled && supabaseClient) {
                statusEl.textContent = '‚òÅÔ∏è Loading from Supabase';
                statusEl.style.color = '#3498db';
            } else {
                statusEl.textContent = 'üíæ Loading from local storage';
                statusEl.style.color = '#7f8c8d';
            }
            
            if (savedEvents.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 20px;">No saved events yet</p>';
                return;
            }
            
            renderEventsList(savedEvents);
        }
        
        function clearLocalStorage() {
            if (!confirm('Clear all local events? This will remove events stored on this device.\n\n' +
                         'Note: Events saved to Supabase will NOT be deleted and will still be accessible.')) {
                return;
            }
            
            localStorage.removeItem('golfEvents');
            console.log('localStorage cleared');
            alert('Local events cleared. Refresh the list to see Supabase events.');
            refreshEventsList();
        }

        async function filterSavedEvents() {
            const searchTerm = document.getElementById('eventSearch').value.toLowerCase();
            const savedEvents = await getAllSavedEvents();
            const filtered = savedEvents.filter(e => e.name.toLowerCase().includes(searchTerm));
            renderEventsList(filtered);
        }

        function renderEventsList(events) {
            const container = document.getElementById('savedEventsList');
            
            if (events.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 20px;">No matching events found</p>';
                return;
            }
            
            let html = '<div style="display: grid; gap: 10px; max-height: 300px; overflow-y: auto;">';
            
            events.sort((a, b) => new Date(b.savedDate) - new Date(a.savedDate)).forEach(evt => {
                const savedDate = new Date(evt.savedDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                
                // Determine event source
                const isLocalOnly = typeof evt.id === 'string' && evt.id.startsWith('local_');
                const sourceIcon = isLocalOnly ? 'üíæ' : '‚òÅÔ∏è';
                const sourceText = isLocalOnly ? 'Local only' : 'Cloud synced';
                const sourceColor = isLocalOnly ? '#95a5a6' : '#3498db';
                
                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px; border: 2px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <div style="font-weight: 600; font-size: 1.1em; color: #2c3e50;">
                                    ${evt.name}
                                </div>
                                <div style="font-size: 0.8em; color: ${sourceColor}; background: ${sourceColor}15; padding: 2px 8px; border-radius: 12px;">
                                    ${sourceIcon} ${sourceText}
                                </div>
                            </div>
                            <div style="font-size: 0.9em; color: #7f8c8d;">
                                ${evt.rounds ? evt.rounds.length : 0} round${evt.rounds && evt.rounds.length > 1 ? 's' : ''} ‚Ä¢ ${evt.scoringType === 'match' ? 'Match Play' : 'Stroke Play'} ‚Ä¢ Saved ${savedDate}
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="loadSavedEvent('${evt.id}')" style="padding: 8px 16px;">
                                üìÇ Load
                            </button>
                            <button class="btn btn-danger" onclick="deleteSavedEvent('${evt.id}')" style="padding: 8px 16px;">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        function updateSupabaseStatusIndicator() {
            const statusEl = document.getElementById('supabaseStatus');
            if (!statusEl) return;
            
            if (isSupabaseEnabled) {
                statusEl.innerHTML = '‚òÅÔ∏è Cloud Sync Enabled - Multi-device sync active';
                statusEl.style.color = '#2ecc71';
            } else {
                statusEl.innerHTML = 'üíæ Local Storage Only - Using browser storage';
                statusEl.style.color = '#95a5a6';
            }
        }
        
        // Initialize
        document.getElementById('numRounds').addEventListener('change', updateRoundFormats);
        updateRoundFormats();
        renderBothRosters();
        refreshEventsList();
        updateSupabaseStatusIndicator();
        // Restore saved API key
        const _savedKey = localStorage.getItem('anthropicApiKey');
        if (_savedKey) document.getElementById('anthropicApiKey').value = _savedKey;
        updateAnthropicKeyStatus();
    </script>
</body>
</html>